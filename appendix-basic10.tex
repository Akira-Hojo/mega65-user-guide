\chapter{BASIC 10 Command Reference}

\section{Format of Commands, Functions and Operators}

In this appendix each of the commands, functions and other callable elements of
BASIC 10 are described.
Some of these can take one or more arguments, that is, pieces of input that you
can (or sometimes must) provide as part of the command or function call.
Some also require that you use special keywords.
Here is an example of how commands, functions and operators will be described
in this appendix:

{\bf KEY <numeric expression>,<string expression> }

In this case, KEY is what we call a {\bf keyword}. That just means a special word that BASIC
understands.  Keywords are always written in CAPITALS, so that you can easily recognise them.

The {\bf <} and {\bf >} signs mean that whatever is between them must be there for the command, function or operator to work.
In this case, it tells us that we need to have a {\bf numeric expression} in one place, and a {\bf string expression} in another place.
We'll explain what there are a bit more in a few moments.

You might also see square brackets around something, for example, {\bf [,numeric expression]}.
This means that whatever appears between the square brackets is optional, that is, you can include it if you need to, but
that the command, function or operator will work just fine without it.  For example, the \screentext{CIRCLE} command has
an optional numeric argument to indicate if the circle should be filled when being drawn.

The comma, and some other symbols and punctuation marks just represent themselves.
In this case, it means that there must be a comma between the {\bf numeric expression} and the {\bf string expression}.
This is what we call syntax: If you miss something out, or put the wrong thing in the wrong place, it is called a
syntax error, and the computer will tell you if you have a syntax error by giving a \screentext{?SYNTAX ERROR} message.

There is nothing to worry about getting an error from the computer.
Instead, it is just the computer's way of telling you that something isn't quite right, so that you can more easily
find and fix the problem.
Error messages like this can't hurt the computer or damage your program, so there is nothing to worry about.
For example, if we accidentally left the comma out, or replaced it with a full-stop, the computer will respond with
a syntax error, like this:

\begin{screenoutput}
  KEY 8"FISH"

  ?SYNTAX ERROR

  KEY 8."FISH"

  ?SYNTAX ERROR
\end{screenoutput}

It is very common for commands, functions and operators to use one or more {\bf``expression''}.
An expression is just a fancy name for something that has a value.
This could be a string, such as \screentext{"HELLO"}, or a number, like \screentext{23.7}, or it could be a calculation, that might include
one or more functions or operators, such as \screentext{LEN("HELLO") * (3 XOR 7)}.
Generally speaking, expressions can result in either a string or numeric result.
In this case we call the expressions either string expressions or numeric expressions.
For example, \screentext{"HELLO"} is a {\bf string expression}, while \screentext{23.7} is a {\bf numeric expression}.

It is important to use the correct type of expression when writing your programs.
If you accidentally use the wrong type, the computer will give you a \screentext{?TYPE MISMATCH ERROR}, to say that the type
of expression you gave doesn't match what it expected, that is, there is a mismatch between the type of expression
it expected, and the one you gave.  For example, we will get a \screentext{?TYPE MISMATCH ERROR} if we type the following command,
because \screentext{"POTATO"} is a string expression instead of a numeric expression:

\begin{screenoutput}
  KEY "POTATO","SOUP"
\end{screenoutput}

You can try typing this into the computer yourself now, if you like.


\section{Commands}

Commands are statements that you can use directly from the {\bf READY.} prompt, or from within a program, for example:

\begin{screenoutput}
  PRINT \"HELLO\"
  HELLO

  10 PRINT \"HELLO\"
  RUN
  HELLO
\end{screenoutput}

% =======================================
% Start of the BASIC 10 command reference
% =======================================

\titleformat*{\subsection}{\normalfont\huge\bfseries\color{blue}}

% ***
% ABS
% ***

\newpage
\subsection{ABS}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$B6
\item [Format:] {\bf ABS(x)}
\item [Usage:]  The numeric function {\bf ABS(x)} returns
                the absolute value of the numeric
                argument {\bf x}. \\
               {\bf x} = numeric argument (integer or real expression).
\item [Remarks:] the result is of real type.
\item [Example:] Using {\bf ABS}

\begin{screenoutput}
  PRINT ABS(-123)
  123
  PRINT ABS(4.5)
  4.5
  PRINT ABS(-4.5)
  4.5
\end{screenoutput}
\end{description}

% ***
% AND
% ***

\newpage
\subsection{AND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$AF
\item [Format:] operand {\bf AND} operand
\item [Usage:]  The boolean {\bf AND} operator performs a bitwise
                logical AND operation on two 16 bit values.
                Integer operands are used as they are.
                Real operands are converted to a signed 16 bit integer.
                Logical operands are converted to 16 bit integer
                using \$FFFF, decimal -1 for TRUE
                and \$0000, decimal 0, for FALSE.

   \begin{verbatim}
      0 AND 0  ->  0
      0 AND 1  ->  0
      1 AND 0  ->  0
      1 AND 1  ->  1
   \end{verbatim}

\item [Remarks:] The result is of integer type.
                 If the result is used in a logical context,
                 the value of 0 is regarded as FALSE,
                 all other, nonzero values are regarded as TRUE.
\item [Example:] Using {\bf AND}

\begin{screenoutput}
  PRINT 1 AND 3
  1
  PRINT 128 AND 64
  0
\end{screenoutput}

In most cases the {\bf AND} will be used in {\bf IF} statements.

\begin{screenoutput}
   IF (C >= 0 AND C < 256) THEN PRINT "BYTE VALUE"
\end{screenoutput}
\end{description}

% ******
% APPEND
% ******

\newpage
\subsection{APPEND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0E
\item [Format:]
  {\bf APPEND\# lfn, filename [,D drive] [,U unit] }
\item [Usage:]
   The append command opens an existing sequential file of type
   SEQ or USR for writing and positions the write pointer
   at the end of the file.

   {\bf lfn} = {\bf l}ogical {\bf f}ile {\bf n}umber \\
   1 <= lfn <= 127: line terminator is CR \\
   128 <= lfn <= 255: line terminator is CR LF

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf drive} = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   \screentext{APPEND\#} functions similar to the \screentext{DOPEN\#}
   command, except that if the file already
   exists, the existing content of the file will be retained, and any
   \screentext{PRINT\#} commands made to the
   open file will cause the file to grow longer.

\item [Example:] Open file in append mode:

\begin{screenoutput}
   APPEND#5,"DATA",U9
   APPEND#130,(\$DD),U(UN%)
   APPEND#3,"USER FILE,U"
   APPEND#2,"DATA BASE"
\end{screenoutput}
\end{description}

% ***
% ASC
% ***

\newpage
\subsection{ASC}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C6
\item [Format:] {\bf ASC}(string)
\item [Usage:] The {\bf ASC} function takes the first character of
               the string argument and returns its numeric code value.
               The name is apparently chosen to be a mnemonic to ASCII,
               but the returned value is in fact the so called PETSCII code.
\item [Remarks:]
               {\bf ASC} returns a zero for a null string, which behaviour
               is different to BASIC 2, where ASC("") gave an error.
               The inverse function to {\bf ASC} is {\bf CHR\$}.
\item [Example:] Using {\bf ASC}
\begin{screenoutput}
  PRINT ASC("MEGA")
  77
  PRINT ASC("")
  0
\end{screenoutput}
\end{description}

% ***
% ATN
% ***

\newpage
\subsection{ATN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C1
\item [Format:] {\bf ATN}(numeric expression)
\item [Usage:] The {\bf ATN} function returns the arc tangent of the
               argument.
               The result is in the range ($-\pi/2$ to $\pi/2$)

\item [Remarks:]
               A multiplication of the result with $180/\pi$
               converts the value to the unit "degrees".
               {\bf ATN} is the inverse function to {\bf TAN}.
\item [Example:] Using {\bf ATN}
\begin{screenoutput}
  PRINT ATN(0.5)
   .463647609
  PRINT ATN(0.5) * 180 /π
   26.5650512
\end{screenoutput}
\end{description}

% PGS 20190309
% XXX BUG - The Pi character (unicode 0x3c0, can be entered in emacs
% with C-x 8 RET 3c0 RET) appears in the wrong place, if it is not
% preceeded by a space.  I have no idea why this is.
% Worked around by putting white space before the PI character,
% but this is far from ideal in terms of the appearance of the output

% ****
% AUTO
% ****

\newpage
\subsection{AUTO}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$DC
\item [Format:]
  {\bf AUTO [step]}
\item [Usage:] The AUTO command enables faster typing of BASIC programs.
  After submitting a new program line to the BASIC editor with
  the RETURN key, the AUTO function generates a new BASIC line
  number for the entry of the next line. The new number is
  computed by adding {\bf step} to the current line number.

  {\bf step} = line number increment

  Typing {\bf AUTO} with no argument switches this fuction off.

\item [Example:] \screentext{AUTO 10} - use AUTO with increment 10 \\
                 \screentext{AUTO}  - switch AUTO off
\end{description}

% **********
% BACKGROUND
% **********

\newpage
\subsection{BACKGROUND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$3B
\item [Format:] {\bf BACKGROUND} colour
\item [Usage:] The {\bf BACKGROUND} command sets the background colour
               of the screen to the argument, which must be in the
               range 0 to 15. (See colour table).
\item [Example:] \screentext{BACKGROUND  3} - select background colour cyan.
\item [Colours:] {\bf Index and RGB values of colour pallette}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{*{4}{|R{1.2cm}}|l|}
\hline
 index  &   red & green & blue & colour \\
\hline
  0 &    0  &   0   &  0   & black \\
  1 &   15  &  15   & 15   & white \\
  2 &   15  &   0   &  0   & red   \\
  3 &    0  &  15   & 15   & cyan  \\
  4 &   15  &   0   & 15   & magenta\\
  5 &    0  &  15   &  0   & green \\
  6 &    0  &   0   & 15   & blue  \\
  7 &   15  &  15   &  0   & yellow\\
  8 &   15  &   6   &  0   & orange\\
  9 &   10  &   4   &  0   & brown \\
 10 &   15  &   7   &  7   & pink  \\
 11 &    5  &   5   &  5   & dark grey\\
 12 &    8  &   8   &  8   & medium grey\\
 13 &    9  &  15   &  9   & light green \\
 14 &    9  &   9   & 15   & light blue\\
 15 &   11  &  11   & 11   & light grey\\
\hline
\end{tabular}
}
\end{description}

% ******
% BACKUP
% ******

\newpage
\subsection{BACKUP}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F6
\item [Format:] {\bf BACKUP D source TO D target [,U unit]}
\item [Usage:] The {\bf BACKUP} command can be used on dual drive
   disk units only (e.g. 4040, 8050, 8250).
   The backup is done by the disk unit internally.

   {\bf source} = drive \# of source disk (0 or 1). \\
   {\bf target} = drive \# of target disk (0 or 1).

\item [Remarks:]  The target disk will be formatted and
                 a identical copy of the source disk will be written. \\
                 This command cannot be used for unit to unit copies.

\item [Example:] \screentext{BACKUP D0 TO D1} - copy disk in drive 0 to
                   drive 1 on unit 8 (default).\\
                 \screentext{BACKUP D1 TO D0, U9} - copy disk in drive 1 to
                   drive 0 on unit 9.
\end{description}

% ****
% BANK
% ****

\newpage
\subsection{BANK}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$02
\item [Format:] {\bf BANK} banknumber
\item [Usage:] The {\bf BANK} command selects the memory configuration
               for BASIC commands, that use 16 bit addresses.
               These are LOAD, SAVE, PEEK, POKE, WAIT and SYS.
               See system memory map for details.
\item [Remarks:] A value > 127 selects memory mapped I/O.
                 The default value for the bank number is 128.
\item [Example:] \screentext{BANK 1} - select memory configuration 1.
\end{description}

% *****
% BEGIN
% *****

\newpage
\subsection{BEGIN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$18
\item [Format:] {\bf BEGIN} ... {\bf BEND}
\item [Usage:] The {\bf BEGIN} and {\bf BEND} keywords act like
               a pair of brackets around a compound statement
               to be executed after a {\bf THEN} or {\bf ELSE} keyword.
               This overcomes the single line limitation of the
               standard {\bf IF} ... {\bf THEN} ... {\bf ELSE} clause.
\item [Remarks:] Do not jump with {\bf GOTO} or {\bf GOSUB} into a
                 compound statement. It may lead to unexpected
                 results.
\item [Example:] Using {\bf BEGIN} and {\bf BEND}
\begin{screenoutput}
10 GET A$
20 IF A$>="A" AND A$<="Z" THEN BEGIN
30 PW$=PW$+A$
40 IF LEN(PW$)>7 THEN 90
50 BEND :REM IGNORE ALL EXCEPT (A-Z)
60 IF A$<>CHR$(13) GOTO 10
90 PRINT "PW=";PW$
\end{screenoutput}
\end{description}

% ****
% BEND
% ****

\newpage
\subsection{BEND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$19
\item [Format:] {\bf BEGIN} ... {\bf BEND}
\item [Usage:] The {\bf BEGIN} and {\bf BEND} keywords act like
               a pair of brackets around a compound statement
               to be executed after a {\bf THEN} or {\bf ELSE} keyword.
               This overcomes the single line limitation of the
               standard {\bf IF} ... {\bf THEN} ... {\bf ELSE} clause.
\item [Remarks:] The example below shows a quirk in the implementation
                 of the compound statement.
                 If the condition evaluates to {\bf FALSE}, execution
                 does not resume right after {\bf BEND} as it should,
                 but at the beginning of next line.
                 Test this behaviour with the following program:
\item [Example:] Using {\bf BEGIN} and {\bf BEND}
\begin{screenoutput}
10 IF Z > 1 THEN BEGIN:A$="ONE"
20 B$="TWO"
30 PRINT A$;" ";B$;:BEND:PRINT " QUIRK"
40 REM EXECUTION RESUMES HERE FOR Z <= 1
\end{screenoutput}
\end{description}

% *****
% BLOAD
% *****

\newpage
\subsection{BLOAD}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$11
\item [Format:] {\bf BLOAD filename [,B bank]
                [,P address]  [,D drive] [,U unit] }
\item [Usage:]
   The {\bf BLOAD} ("Binary LOAD") loads a file of type
   PRG into RAM at address P and bank B.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf address} can be used to overrule the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf drive} = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   If the loading process tries to load beyond the address \$FFFF,
   an 'OUT OF MEMORY' error occurs.

\item [Example:] Using {\bf BLOAD}
\begin{screenoutput}
  BLOAD "ML DATA", B0, U9
  BLOAD "SPRITES"
  BLOAD "ML ROUTINES", B1, P32768
  BLOAD (FN$), B(BA%), P(PA), U(UN%)
\end{screenoutput}
\end{description}

% ****
% BOOT
% ****

\newpage
\subsection{BOOT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$1B
\item [Format:] {\bf BOOT filename [,B bank]
                [,P address]  [,D drive] [,U unit] } \\
                {\bf BOOT SYS} \\
                {\bf BOOT} 
\item [Usage:]
   The {\bf BOOT filename} loads a file of type
   PRG into RAM at address P and bank B and starts executing
   the code at the load address.

   The {\bf BOOT SYS} loads the boot sector from sector 0,
   track 1 and unit 8 to address \$0400 on bank 0 and
   performs a JSR \$0400 afterwards (Jump To Subroutine).

   The {\bf BOOT} command with no parameter tries to load
   and execute a file named AUTOBOOT.C65 from the default unit 8.
   It's short for {\bf RUN "AUTOBOOT.C65"}.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf address} can be used to overrule the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf drive} = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   {\bf BOOT SYS} copies the contents of one physical sector
   (two logical sectors) = 512 bytes from disc to RAM,
   filling RAM from \$0400 to \$05ff.

\item [Example:] Using {\bf BOOT}
\begin{screenoutput}
  BOOT SYS
  BOOT (FN$), B(BA%), P(PA), U(UN%)
  BOOT
\end{screenoutput}
\end{description}

% ******
% BORDER
% ******

\newpage
\subsection{BORDER}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$3C
\item [Format:] {\bf BORDER} colour
\item [Usage:] The {\bf BORDER} command sets the border colour
               of the screen to the argument, which must be in the
               range 0 to 15. (See colour table).
\item [Example:] \screentext{BORDER  4} - select background colour magenta.
\item [Colours:] {\bf Index and RGB values of colour pallette}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{*{4}{|R{1.2cm}}|l|}
\hline
 index  &   red & green & blue & colour \\
\hline
  0 &    0  &   0   &  0   & black \\
  1 &   15  &  15   & 15   & white \\
  2 &   15  &   0   &  0   & red   \\
  3 &    0  &  15   & 15   & cyan  \\
  4 &   15  &   0   & 15   & magenta\\
  5 &    0  &  15   &  0   & green \\
  6 &    0  &   0   & 15   & blue  \\
  7 &   15  &  15   &  0   & yellow\\
  8 &   15  &   6   &  0   & orange\\
  9 &   10  &   4   &  0   & brown \\
 10 &   15  &   7   &  7   & pink  \\
 11 &    5  &   5   &  5   & dark grey\\
 12 &    8  &   8   &  8   & medium grey\\
 13 &    9  &  15   &  9   & light green \\
 14 &    9  &   9   & 15   & light blue\\
 15 &   11  &  11   & 11   & light grey\\
\hline
\end{tabular}
}
\end{description}

% ***
% BOX
% ***

\newpage
\subsection{BOX}

\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E1
\item [Format:] {\bf BOX X0,Y0, X1,Y1, X2,Y2, X3,Y3, SOLID}
\item [Usage:] {\bf BOX} draws a polygon by connecting the
               coordinate pairs 0 -> 1 -> 2 -> 3 -> 0.
               The polygon is drawn using the current drawing context
               set with SCREEN, PALETTE and PEN.
               The polygon is filled, if the parameter SOLID is 1.

\item [Remarks:] It is possible to draw bowtie shapes.
\item [Example:] Using {\bf BOX}
\begin{screenoutput}
  BOX 0,0, 160,0, 160,80, 0,80
\end{screenoutput}
\begin{tikzpicture}[thick]
\draw (4cm,0cm) -- (8cm,0cm) -- (8cm,2cm) -- (4cm,2cm) -- (4cm,0cm);
\end{tikzpicture}
\begin{screenoutput}
  BOX 0,0, 160,80, 160,0, 0,80
\end{screenoutput}
\begin{tikzpicture}[thick]
\draw (4cm,0cm) -- (8cm,2cm) -- (8cm,0cm) -- (4cm,2cm) -- (4cm,0cm);
\end{tikzpicture}
\begin{screenoutput}
  BOX 0,0, 160,0, 140,80, 20,80
\end{screenoutput}
\begin{tikzpicture}[thick]
\draw (5cm,0cm) -- (7cm,0cm) -- (8cm,2cm) -- (4cm,2cm) -- (5cm,0cm);
\end{tikzpicture}
\end{description}

% *****
% BSAVE
% *****

\newpage
\subsection{BSAVE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$10
\item [Format:] {\bf BSAVE filename ,P start TO end
                [,B bank] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf BSAVE} ("Binary SAVE") saves a memory range to
   a file of type PRG.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}
   If the first character of the filename is an at-sign '@' it
   is interpreted as a "save and replace" operation. It is dangerous
   to use this replace option on drives 1541 and 1571, because they
   contain the notorious "save and replace bug" in their DOS.

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf start} is the first address, where the saving begins.
   It becomes also the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf end} Is the address, where the saving stops.
   {\bf end-1} is the last address to be used for saving.

   {\bf drive} = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The length of the file is {\bf end - start + 2}. \\

\item [Example:] Using {\bf BSAVE}
\begin{screenoutput}
  BSAVE "ML DATA", P 32768 TO 33792, B0, U9
  BSAVE "SPRITES", P 1536 TO 2058
  BSAVE "ML ROUTINES", B1, P(DEC("9000")) TO (DEC("A000"))
  BSAVE (FN$), B(BA%), P(PA) TO (PE), U(UN%)
\end{screenoutput}
\end{description}

% ****
% BUMP
% ****

\newpage
\subsection{BUMP}

\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$CE \$03
\item [Format:] {\bf b = BUMP(type)}
\item [Usage:]  The {\bf BUMP} function can be used to detect
               sprite-sprite (type=1) or sprite-data (type=2) collisions.
               the return value {\bf b} is a 8 bit mask with
               1 bit per sprite. The bit position corresponds with the
               sprite number.
               Eachs bit set in the return value indicates, that the
               sprite for this postion was involved in a collision
               since the last call of {\bf BUMP}.
               Calling {\bf BUMP} resets the collision mask, so you
               get always a summary of collisions encountered since
               the last call of {\bf BUMP}.

\item [Remarks:] It is possible to detect multiple collisions,
               but you need to evaluate sprite coordinates then
               to detect which sprite collided with which one.

\item [Example:] Using {\bf BUMP}
\begin{screenoutput}
  S% = BUMP(1) : REM SPRITE-SPRITE COLLISION
  IF (S% AND 6) = 6) THEN PRINT "SPRITE 1 & 2 COLLISION"

  S% = BUMP(2) : REM SPRITE-DATA COLLISION
  IF (S% <> 0) THEN PRINT "SOME SPRITE HIT DATA REGION"
\end{screenoutput}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{|R{12mm}|R{12mm}|l|}
\hline
 sprite  & return & mask \\
\hline
  0 &    1  & 0000 0001 \\
  1 &    2  & 0000 0010 \\
  2 &    4  & 0000 0100 \\
  3 &    8  & 0000 1000 \\
  4 &   16  & 0001 0000 \\
  5 &   32  & 0010 0000 \\
  6 &   64  & 0100 0000 \\
  7 &  128  & 1000 0000 \\
\hline
\end{tabular}
}
\end{description}

% *******
% BVERIFY
% *******

\newpage
\subsection{BVERIFY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$28
\item [Format:] {\bf BVERIFY filename [,P address]
                [,B bank] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf BVERIFY} ("Binary VERIFY") compares a memory range to
   a file of type PRG.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf address} is the address, where the comparison begins.
   If the parameter P is omitted, it is the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf drive} = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   {\bf BVERIFY} can only test for equality. It gives no information
   about the number or position of different valued bytes.
   In direct mode the command exits either with the message {\bf OK}
   or with {\bf VERIFY ERROR}. In program mode a {\bf VERIFY ERROR}
   either stops execution or enters the {\bf TRAP} error handler,
   if active.

\item [Example:] Using {\bf BVERIFY}
\begin{screenoutput}
  BVERIFY "ML DATA", P 32768, B0, U9
  BVERIFY "SPRITES", P 1536
  BVERIFY "ML ROUTINES", B1, P(DEC("9000"))
  BVERIFY (FN$), B(BA%), P(PA), U(UN%)
\end{screenoutput}
\end{description}

% *******
% CATALOG
% *******

\newpage
\subsection{CATALOG}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0C
\item [Format:] {\bf CATALOG [filepattern] [,R] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf CATALOG} command prints a full or partial listing
   of the specified disk.

   {\bf filepattern} is either a quoted string, e.g. {\bf "da*"} or
   a string expression in parentheses, e.g. {\bf (DI\$)}

   {\bf drive} = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The command {\bf CATALOG} is a synonym for {\bf DIRECTORY}
   or {\bf DIR} and produces the same listing.
   The {\bf filepattern} can be used to restrict the listing.
   The wildcard characters '*' and '?' may be used.

\item [Example:] Using {\bf CATALOG}
\begin{screenoutput}
  CATALOG

  0 "BLACK SMURF     " BS  2A
508 "STORY PHOBOS"         SEQ
27  "C8096"                PRG
25  "C128"                 PRG
104 BLOCKS FREE.

  CATALOG "C*"

  0 "BLACK SMURF     " BS  2A
27  "C8096"                PRG
25  "C128"                 PRG
104 BLOCKS FREE.

\end{screenoutput}
\end{description}

% ******
% CHANGE
% ******

\newpage
\subsection{CHANGE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0C
\item [Format:] {\bf CHANGE "find" TO "replace" [,from-to]}
\item [Usage:]  {\bf CHANGE} is an editor command and can be used
                in direct mode only. It searches the line range
                if specified or the whole BASIC program else.
                At each occurence of the "find string" the line is
                listed and the user prompted for an action: \\
                'Y' <RETURN> do the change and find next string \\
                'N' <RETURN> do {\bf not} change and find next string \\
                '*' <RETURN> change this and all following matches \\
                    <RETURN> exit command, don't change.
\item [Remarks:] Instead of the quote (") each other character may be used
                 as delimiter for the findstring and replacestring.
                 Using the quote as delimiter finds text strings, that are
                 not tokenized and therefore not part of a keyword. \\
                 \screentext{CHANGE "LOOP" TO "OOPS"} will not find
                 the BASIC keyword \screentext{LOOP}, because the
                 keyword is stored as token and not as text.
                 However \screentext{CHANGE \&LOOP\& TO \&OOPS\&} will
                 find and replace it (probably spoiling the program).


\item [Example:] Using {\bf CHANGE}
\begin{screenoutput}
CHANGE "XX$" TO "UU$", 2000-2700
CHANGE &IN& TO &OUT&
\end{screenoutput}
\end{description}

% ****
% CHAR
% ****

\newpage
\subsection{CHAR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E0
\item [Format:] {\bf CHAR column, row, height, width, direction, string
                [, address of character set]}
\item [Usage:]  {\bf CHAR} is used to display text on a graphic screen.
                It can be used for all resolutions.

                {\bf column} is the start position of the output
                in horizontal direction.
                One column is 8 pixels wide, so a screen width of 320
                has a column range 0 -> 39, while a width of 640
                has a range of 0 -> 79.

                {\bf row} is the start position of the output
                in vertical direction. Other than column, its unit is
                pixel with top row having the value 0.

                {\bf height} is a factor applied to the vertical
                size of the characters. 1 is normal size (8 pixels)
                2 is double size (16 pixels), etc.

                {\bf widht} is a factor applied to the horizontal
                size of the characters. 1 is normal size (8 pixels)
                2 is double size (16 pixels), etc.

                {\bf direction} controls the printing direction: \\
                1: up     \\
                2: right  \\
                4: down   \\
                8: left

                The optional {\bf address of character set} can be used
                to select a character set different from the default
                character set at \$29800, which is the set with
                upper/lower characters.

                {\bf string} is a string constant or expression
                which will be printed.

\item [Remarks:]
                Control characters,
                e.g. cursor movement codes, will be ignored
                (neither printed nor interpreted).


\item [Example:] Using {\bf CHAR}
\begin{screenoutput}
CHAR 304,196, 1,1,2,  "MEGA 65"
\end{screenoutput}
will printh the text "MEGA 65" on the centre of a 640 x 400 graphic screen.
\end{description}

% ****
% CHR$
% ****

\newpage
\subsection{CHR\$}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C1
\item [Format:] {\bf CHR\$(numeric expression)}
\item [Usage:] The {\bf CHR\$} function returns a string of length 1
               using the argument to insert the character having this
               value as PETSCII code.

\item [Remarks:] The argument range is 0 -> 255, so this function may
                 also be used to insert control codes into strings.
                 Even the NULL character, with code 0, is allowed. \\
               {\bf CHR\$} is the inverse function to {\bf ASC}.
\item [Example:] Using {\bf CHR\$}
\begin{screenoutput}
10 QUOTE$   = CHR$(34)
20 ESCAPE$  = CHR$(27)
30 PRINT QUOTE$;"MEGA 65";QUOTE$ : REM PRINT "MEGA 65"
40 PRINT ESCAPE$;"Q";       : REM CLEAR TO END OF LINE
\end{screenoutput}
\end{description}

% ******
% CIRCLE
% ******

\newpage
\subsection{CIRCLE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E2
\item [Format:] {\bf CIRCLE xcentre, ycentre, radius, [,solid]}
\item [Usage:] The {\bf CIRCLE} command is a special case of
               the {\bf ELLIPSE} command using the same value for
               horizontal and vertical radius.

               {\bf xcentre} x coordinate of centre in pixels.

               {\bf ycentre} y coordinate of centre in pixels.

               {\bf radius} radius of the circle in pixels.

               {\bf solid} will fill the circle if not zero.

\item [Remarks:] The {\bf CIRCLE} command is used to draw circles on
               screens with an aspect ratio 1:1 (e.g. 320 x200
               or 640 x 400). On other resolutions (e.g. 640 x 200)
               the shape will degrade to an ellipse.

\item [Example:] Using {\bf CIRCLE}
\begin{screenoutput}
10 REM USE A 640 X 400 SCREEN
20 CIRCLE 320,200,100
30 REM DRAW CIRCLE IN THE CENTRE OF THE SCREEN
\end{screenoutput}
\end{description}

% *****
% CLOSE
% *****

\newpage
\subsection{CLOSE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A0
\item [Format:] {\bf CLOSE channel}
\item [Usage:] The {\bf CLOSE} command closes an input or output
               channel, that was established before by an {\bf OPEN}
               command.

               {\bf channel} is a value in the range 0 -> 255.

\item [Remarks:] Closing open files before the program stops is
               very important, especially for output files.
               This command flushes output buffers and
               updates directory informations on disks.
               Failing to {\bf CLOSE}  can corrupt files and disks.
               BASIC does NOT automatically close channels or files
               when the program stops.

\item [Example:] Using {\bf CLOSE}
\begin{screenoutput}
10 OPEN 2,8,2,"TEST,S,W"
20 PRINT#2,"TESTSTRING"
30 CLOSE 2 : REM OMITTING CLOSE GENERATES A SPLAT FILE
\end{screenoutput}
\end{description}

% ***
% CLR
% ***

\newpage
\subsection{CLR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$9C
\item [Format:] {\bf CLR}
\item [Usage:] The {\bf CLR} command resets all pointers, that
               are used for management of BASIC variables, arrays
               and strings. The runtime stack pointers are reset
               and the table of open channels is reset.
               A {\bf RUN} command performs {\bf CLR} automatically.

\item [Remarks:] {\bf CLR} should not be used inside loops or
               subroutines because it destroys the return address.
               After a {\bf CLR} all variables are unknown and will
               be initialized at the next usage.

\item [Example:] Using {\bf CLR}
\begin{screenoutput}
10 A=5: P$="MEGA 65"
20 CLR
30 PRINT A;P$

0
READY.
\end{screenoutput}
\end{description}

% ***
% CMD
% ***

\newpage
\subsection{CMD}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$9D
\item [Format:] {\bf CMD channel [,string]}
\item [Usage:] The {\bf CMD} command redirects the standard output
               from screen to the channel. This enables to
               print listings and directories or other screen outputs.
               It is also possible to redirect this output to a disk file
               or a modem.

               {\bf channel} must be opened by the {\bf OPEN} command.

               The optional {\bf string} will be sent to the channel
               before the redirection begins and can be used,
               for example, for printer setup escape sequences.

\item [Remarks:] The {\bf CMD} mode is stopped by a {\bf PRINT\# channel}
                 or by closing the channel with {\bf CLOSE channel}.
                 It is recommended to use a {\bf PRINT\# channel}
                 before closing, to make sure, that the output buffer
                 is flushed.

\item [Example:] Using {\bf CMD} to print a program listing:
\begin{screenoutput}
OPEN 4,4
LIST
PRINT#4
CLOSE 4
\end{screenoutput}
\end{description}

% *******
% COLLECT
% *******

\newpage
\subsection{COLLECT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F3
\item [Format:] {\bf COLLECT [,D drive] [,U unit] }
\item [Usage:]
   The {\bf COLLECT} command rebuilds the {\bf BAM}
   (Block Availabilty Map) deleting splat files and marking
   unused blocks as free.

   {\bf drive} = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   While this command is useful for cleaning the disk from
   splat files (e.g. write files, that weren't properly closed)
   it is dangerous for disks with boot blocks or random access files.
   These blocks are not associated with standard disk files
   and will therefore be marked as free too and may be overwritten
   by further disk write operations.

\item [Example:] Using {\bf COLLECT}
\begin{screenoutput}
  COLLECT
  COLLECT U9
  COLLECT D0, U9
\end{screenoutput}
\end{description}

% *********
% COLLISION
% *********

\newpage
\subsection{COLLISION}

\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$17
\item [Format:] {\bf COLLISION type [,linenumber]}
\item [Usage:]  The {\bf COLLISION} statement enables or disables
                an user programmed interrupt handler.
                A call without linenumber disables the handler,
                while a call with linenumber enables it.
                After the execution of {\bf COLLISION} with
                linenumber a sprite collision of the same type,
                as specified in the {\bf COLLISION} call, will
                interrupt the BASIC program and perform a {\bf GOSUB}
                to {\bf linenumber} which is expected to contain
                the user code for handling sprite collisions.
                This handler must give control back with a {\bf RETURN}.

                {\bf type} specifies the collision type for
                this interrupt handler: \\
                1 = sprite - sprite collision \\
                2 = sprite - data - collision \\
                3 = light pen

                {\bf linenumber} must point to a subroutine
                which holds code for handling sprite collision
                and ends with a {\bf RETURN}.

\item [Remarks:] It is possible to enable interrupt handler for
               all types, but only one can execute at any time.
               A interrupt handler cannot be interrupted by another
               interrupt handler.
               Functions like {\bf BUMP}, {\bf RSPPOS} and
               {\bf LPEN} may be used for evaluation of the sprites
               which are involved and their positions.

\item [Example:] Using {\bf COLLISION}
\begin{screenoutput}
10 COLLISION 1,70 : REM ENABLE
20 SPRITE 1,1 : MOVSPR 1,120,  0 : MOVSPR 1,0#5
30 SPRITE 2,1 : MOVSPR 2,120,100 : MOVSPR 2,180#5
40 FOR I=1 TO 50000:NEXT
50 COLLISION 1 : REM DISABLE
50 END
70 REM SPRITE <-> SPRITE INTERRUPT HANDLER
80 PRINT "BUMP RETURNS";BUMP(1)
90 RETURN: REM RETURN FROM INTERRUPT
\end{screenoutput}
\end{description}



%\newpage
%\subsection{}
%
%\begin{description}[leftmargin=3cm,style=nextline]
%\item [Token:]
%\item [Format:]
%\item [Usage:]
%\item [Remarks:]
%\item [Example:]
%\end{description}

