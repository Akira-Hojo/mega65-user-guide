\chapter{BASIC 10 Command Reference}

\section{Format of Commands, Functions and Operators}

In this appendix each of the commands, functions and other callable elements of
BASIC 10 are described.
Some of these can take one or more arguments, that is, pieces of input that you
can (or sometimes must) provide as part of the command or function call.
Some also require that you use special keywords.
Here is an example of how commands, functions and operators will be described
in this appendix:

{\bf KEY <numeric expression>,<string expression> }

In this case, KEY is what we call a {\bf keyword}. That just means a special word that BASIC
understands.  Keywords are always written in CAPITALS, so that you can easily recognise them.

The {\bf <} and {\bf >} signs mean that whatever is between them must be there for the command, function or operator to work.
In this case, it tells us that we need to have a {\bf numeric expression} in one place, and a {\bf string expression} in another place.
We'll explain what there are a bit more in a few moments.

You might also see square brackets around something, for example, {\bf [,numeric expression]}.
This means that whatever appears between the square brackets is optional, that is, you can include it if you need to, but
that the command, function or operator will work just fine without it.  For example, the \screentext{CIRCLE} command has
an optional numeric argument to indicate if the circle should be filled when being drawn.

The comma, and some other symbols and punctuation marks just represent themselves.
In this case, it means that there must be a comma between the {\bf numeric expression} and the {\bf string expression}.
This is what we call syntax: If you miss something out, or put the wrong thing in the wrong place, it is called a
syntax error, and the computer will tell you if you have a syntax error by giving a \screentext{?SYNTAX ERROR} message.

There is nothing to worry about getting an error from the computer.
Instead, it is just the computer's way of telling you that something isn't quite right, so that you can more easily
find and fix the problem.
Error messages like this can't hurt the computer or damage your program, so there is nothing to worry about.
For example, if we accidentally left the comma out, or replaced it with a full-stop, the computer will respond with
a syntax error, like this:

\begin{screenoutput}
KEY 8"FISH"

?SYNTAX ERROR

KEY 8."FISH"

?SYNTAX ERROR
\end{screenoutput}

It is very common for commands, functions and operators to use one or more {\bf``expression''}.
An expression is just a fancy name for something that has a value.
This could be a string, such as \screentext{"HELLO"}, or a number, like \screentext{23.7}, or it could be a calculation, that might include
one or more functions or operators, such as \screentext{LEN("HELLO") * (3 XOR 7)}.
Generally speaking, expressions can result in either a string or numeric result.
In this case we call the expressions either string expressions or numeric expressions.
For example, \screentext{"HELLO"} is a {\bf string expression}, while \screentext{23.7} is a {\bf numeric expression}.

It is important to use the correct type of expression when writing your programs.
If you accidentally use the wrong type, the computer will give you a \screentext{?TYPE MISMATCH ERROR}, to say that the type
of expression you gave doesn't match what it expected, that is, there is a mismatch between the type of expression
it expected, and the one you gave.  For example, we will get a \screentext{?TYPE MISMATCH ERROR} if we type the following command,
because \screentext{"POTATO"} is a string expression instead of a numeric expression:

\begin{screenoutput}
  KEY "POTATO","SOUP"
\end{screenoutput}

You can try typing this into the computer yourself now, if you like.


\section{Commands}

Commands are statements that you can use directly from the {\bf READY.} prompt, or from within a program, for example:

\begin{screenoutput}
  PRINT "HELLO"
  HELLO

  10 PRINT "HELLO"
  RUN
  HELLO
\end{screenoutput}

% =======================================
% Start of the BASIC 10 command reference
% =======================================

\titleformat*{\subsection}{\normalfont\huge\bfseries\color{blue}}

% ***
% ABS
% ***

\newpage
\subsection{ABS}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$B6
\item [Format:] {\bf ABS(x)}
\item [Usage:]  The numeric function {\bf ABS(x)} returns
                the absolute value of the numeric
                argument {\bf x}. \\
               {\bf x} = numeric argument (integer or real expression).
\item [Remarks:] the result is of real type.
\item [Example:] Using {\bf ABS}

\begin{screenoutput}
  PRINT ABS(-123)
  123
  PRINT ABS(4.5)
  4.5
  PRINT ABS(-4.5)
  4.5
\end{screenoutput}
\end{description}

% ***
% AND
% ***

\newpage
\subsection{AND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$AF
\item [Format:] operand {\bf AND} operand
\item [Usage:]  The boolean {\bf AND} operator performs a bitwise
                logical AND operation on two 16 bit values.
                Integer operands are used as they are.
                Real operands are converted to a signed 16 bit integer.
                Logical operands are converted to 16 bit integer
                using \$FFFF, decimal -1 for TRUE
                and \$0000, decimal 0, for FALSE.

   \begin{verbatim}
      0 AND 0  ->  0
      0 AND 1  ->  0
      1 AND 0  ->  0
      1 AND 1  ->  1
   \end{verbatim}

\item [Remarks:] The result is of integer type.
                 If the result is used in a logical context,
                 the value of 0 is regarded as FALSE,
                 all other, nonzero values are regarded as TRUE.
\item [Example:] Using {\bf AND}

\begin{screenoutput}
  PRINT 1 AND 3
  1
  PRINT 128 AND 64
  0
\end{screenoutput}

In most cases the {\bf AND} will be used in {\bf IF} statements.

\begin{screenoutput}
   IF (C >= 0 AND C < 256) THEN PRINT "BYTE VALUE"
\end{screenoutput}
\end{description}

% ******
% APPEND
% ******

\newpage
\subsection{APPEND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0E
\item [Format:]
  {\bf APPEND\# lfn, filename [,D drive] [,U unit] }
\item [Usage:]
   The append command opens an existing sequential file of type
   SEQ or USR for writing and positions the write pointer
   at the end of the file.

   {\bf lfn} = {\bf l}ogical {\bf f}ile {\bf n}umber \\
   1 <= lfn <= 127: line terminator is CR \\
   128 <= lfn <= 255: line terminator is CR LF

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   \screentext{APPEND\#} functions similar to the \screentext{DOPEN\#}
   command, except that if the file already
   exists, the existing content of the file will be retained, and any
   \screentext{PRINT\#} commands made to the
   open file will cause the file to grow longer.

\item [Example:] Open file in append mode:

\begin{screenoutput}
   APPEND#5,"DATA",U9
   APPEND#130,(DD$),U(UN%)
   APPEND#3,"USER FILE,U"
   APPEND#2,"DATA BASE"
\end{screenoutput}
\end{description}

% ***
% ASC
% ***

\newpage
\subsection{ASC}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C6
\item [Format:] {\bf ASC}(string)
\item [Usage:] The {\bf ASC} function takes the first character of
               the string argument and returns its numeric code value.
               The name is apparently chosen to be a mnemonic to ASCII,
               but the returned value is in fact the so called PETSCII code.
\item [Remarks:]
               {\bf ASC} returns a zero for a null string, which behaviour
               is different to BASIC 2, where ASC("") gave an error.
               The inverse function to {\bf ASC} is {\bf CHR\$}.
\item [Example:] Using {\bf ASC}
\begin{screenoutput}
  PRINT ASC("MEGA")
  77
  PRINT ASC("")
  0
\end{screenoutput}
\end{description}

% ***
% ATN
% ***

\newpage
\subsection{ATN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C1
\item [Format:] {\bf ATN}(numeric expression)
\item [Usage:] The {\bf ATN} function returns the arc tangent of the
               argument.
               The result is in the range ($-\pi/2$ to $\pi/2$)

\item [Remarks:]
               A multiplication of the result with $180/\pi$
               converts the value to the unit "degrees".
               {\bf ATN} is the inverse function to {\bf TAN}.
\item [Example:] Using {\bf ATN}
\begin{screenoutput}
  PRINT ATN(0.5)
   .463647609
  PRINT ATN(0.5) * 180 / ~
   26.5650512
\end{screenoutput}
\end{description}

% ****
% AUTO
% ****

\newpage
\subsection{AUTO}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$DC
\item [Format:]
  {\bf AUTO [step]}
\item [Usage:] The AUTO command enables faster typing of BASIC programs.
  After submitting a new program line to the BASIC editor with
  the RETURN key, the AUTO function generates a new BASIC line
  number for the entry of the next line. The new number is
  computed by adding {\bf step} to the current line number.

  {\bf step} = line number increment

  Typing {\bf AUTO} with no argument switches this fuction off.

\item [Example:] \screentext{AUTO 10} - use AUTO with increment 10 \\
                 \screentext{AUTO}  - switch AUTO off
\end{description}

% **********
% BACKGROUND
% **********

\newpage
\subsection{BACKGROUND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$3B
\item [Format:] {\bf BACKGROUND} colour
\item [Usage:] The {\bf BACKGROUND} command sets the background colour
               of the screen to the argument, which must be in the
               range 0 to 15. (See colour table).
\item [Example:] \screentext{BACKGROUND  3} - select background colour cyan.
\item [Colours:] {\bf Index and RGB values of colour pallette}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{*{4}{|R{1.2cm}}|l|}
\hline
 index  &   red & green & blue & colour \\
\hline
  0 &    0  &   0   &  0   & black \\
  1 &   15  &  15   & 15   & white \\
  2 &   15  &   0   &  0   & red   \\
  3 &    0  &  15   & 15   & cyan  \\
  4 &   15  &   0   & 15   & magenta\\
  5 &    0  &  15   &  0   & green \\
  6 &    0  &   0   & 15   & blue  \\
  7 &   15  &  15   &  0   & yellow\\
  8 &   15  &   6   &  0   & orange\\
  9 &   10  &   4   &  0   & brown \\
 10 &   15  &   7   &  7   & pink  \\
 11 &    5  &   5   &  5   & dark grey\\
 12 &    8  &   8   &  8   & medium grey\\
 13 &    9  &  15   &  9   & light green \\
 14 &    9  &   9   & 15   & light blue\\
 15 &   11  &  11   & 11   & light grey\\
\hline
\end{tabular}
}
\end{description}

% ******
% BACKUP
% ******

\newpage
\subsection{BACKUP}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F6
\item [Format:] {\bf BACKUP D source TO D target [,U unit]}
\item [Usage:] The {\bf BACKUP} command can be used on dual drive
   disk units only (e.g. 4040, 8050, 8250).
   The backup is done by the disk unit internally.

   {\bf source} = drive \# of source disk (0 or 1). \\
   {\bf target} = drive \# of target disk (0 or 1).

\item [Remarks:]  The target disk will be formatted and
                 a identical copy of the source disk will be written. \\
                 This command cannot be used for unit to unit copies.

\item [Example:] \screentext{BACKUP D0 TO D1} - copy disk in drive 0 to
                   drive 1 on unit 8 (default).\\
                 \screentext{BACKUP D1 TO D0, U9} - copy disk in drive 1 to
                   drive 0 on unit 9.
\end{description}

% ****
% BANK
% ****

\newpage
\subsection{BANK}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$02
\item [Format:] {\bf BANK} banknumber
\item [Usage:] The {\bf BANK} command selects the memory configuration
               for BASIC commands, that use 16 bit addresses.
               These are LOAD, SAVE, PEEK, POKE, WAIT and SYS.
               See system memory map for details.
\item [Remarks:] A value > 127 selects memory mapped I/O.
                 The default value for the bank number is 128.
\item [Example:] \screentext{BANK 1} - select memory configuration 1.
\end{description}

% *****
% BEGIN
% *****

\newpage
\subsection{BEGIN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$18
\item [Format:] {\bf BEGIN} ... {\bf BEND}
\item [Usage:] The {\bf BEGIN} and {\bf BEND} keywords act like
               a pair of brackets around a compound statement
               to be executed after a {\bf THEN} or {\bf ELSE} keyword.
               This overcomes the single line limitation of the
               standard {\bf IF} ... {\bf THEN} ... {\bf ELSE} clause.
\item [Remarks:] Do not jump with {\bf GOTO} or {\bf GOSUB} into a
                 compound statement. It may lead to unexpected
                 results.
\item [Example:] Using {\bf BEGIN} and {\bf BEND}
\begin{screenoutput}
10 GET A$
20 IF A$>="A" AND A$<="Z" THEN BEGIN
30 PW$=PW$+A$
40 IF LEN(PW$)>7 THEN 90
50 BEND :REM IGNORE ALL EXCEPT (A-Z)
60 IF A$<>CHR$(13) GOTO 10
90 PRINT "PW=";PW$
\end{screenoutput}
\end{description}

% ****
% BEND
% ****

\newpage
\subsection{BEND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$19
\item [Format:] {\bf BEGIN} ... {\bf BEND}
\item [Usage:] The {\bf BEGIN} and {\bf BEND} keywords act like
               a pair of brackets around a compound statement
               to be executed after a {\bf THEN} or {\bf ELSE} keyword.
               This overcomes the single line limitation of the
               standard {\bf IF} ... {\bf THEN} ... {\bf ELSE} clause.
\item [Remarks:] The example below shows a quirk in the implementation
                 of the compound statement.
                 If the condition evaluates to {\bf FALSE}, execution
                 does not resume right after {\bf BEND} as it should,
                 but at the beginning of next line.
                 Test this behaviour with the following program:
\item [Example:] Using {\bf BEGIN} and {\bf BEND}
\begin{screenoutput}
10 IF Z > 1 THEN BEGIN:A$="ONE"
20 B$="TWO"
30 PRINT A$;" ";B$;:BEND:PRINT " QUIRK"
40 REM EXECUTION RESUMES HERE FOR Z <= 1
\end{screenoutput}
\end{description}

% *****
% BLOAD
% *****

\newpage
\subsection{BLOAD}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$11
\item [Format:] {\bf BLOAD filename [,B bank]
                [,P address]  [,D drive] [,U unit] }
\item [Usage:]
   The {\bf BLOAD}Â ("Binary LOAD") loads a file of type
   PRG into RAM at address P and bank B.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf address} can be used to overrule the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   If the loading process tries to load beyond the address \$FFFF,
   an 'OUT OF MEMORY' error occurs.

\item [Example:] Using {\bf BLOAD}
\begin{screenoutput}
  BLOAD "ML DATA", B0, U9
  BLOAD "SPRITES"
  BLOAD "ML ROUTINES", B1, P32768
  BLOAD (FN$), B(BA%), P(PA), U(UN%)
\end{screenoutput}
\end{description}

% ****
% BOOT
% ****

\newpage
\subsection{BOOT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$1B
\item [Format:] {\bf BOOT filename [,B bank]
                [,P address]  [,D drive] [,U unit] } \\
                {\bf BOOT SYS}Â \\
                {\bf BOOT}Â 
\item [Usage:]
   The {\bf BOOT filename}Â loads a file of type
   PRG into RAM at address P and bank B and starts executing
   the code at the load address.

   The {\bf BOOT SYS}Â loads the boot sector from sector 0,
   track 1 and unit 8 to address \$0400 on bank 0 and
   performs a JSR \$0400 afterwards (Jump To Subroutine).

   The {\bf BOOT} command with no parameter tries to load
   and execute a file named AUTOBOOT.C65 from the default unit 8.
   It's short for {\bf RUN "AUTOBOOT.C65"}.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf address} can be used to overrule the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   {\bf BOOT SYS}Â copies the contents of one physical sector
   (two logical sectors) = 512 bytes from disc to RAM,
   filling RAM from \$0400 to \$05ff.

\item [Example:] Using {\bf BOOT}
\begin{screenoutput}
  BOOT SYS
  BOOT (FN$), B(BA%), P(PA), U(UN%)
  BOOT
\end{screenoutput}
\end{description}

% ******
% BORDER
% ******

\newpage
\subsection{BORDER}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$3C
\item [Format:] {\bf BORDER} colour
\item [Usage:] The {\bf BORDER} command sets the border colour
               of the screen to the argument, which must be in the
               range 0 to 15. (See colour table).
\item [Example:] \screentext{BORDER  4} - select background colour magenta.
\item [Colours:] {\bf Index and RGB values of colour pallette}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{*{4}{|R{1.2cm}}|l|}
\hline
 index  &   red & green & blue & colour \\
\hline
  0 &    0  &   0   &  0   & black \\
  1 &   15  &  15   & 15   & white \\
  2 &   15  &   0   &  0   & red   \\
  3 &    0  &  15   & 15   & cyan  \\
  4 &   15  &   0   & 15   & magenta\\
  5 &    0  &  15   &  0   & green \\
  6 &    0  &   0   & 15   & blue  \\
  7 &   15  &  15   &  0   & yellow\\
  8 &   15  &   6   &  0   & orange\\
  9 &   10  &   4   &  0   & brown \\
 10 &   15  &   7   &  7   & pink  \\
 11 &    5  &   5   &  5   & dark grey\\
 12 &    8  &   8   &  8   & medium grey\\
 13 &    9  &  15   &  9   & light green \\
 14 &    9  &   9   & 15   & light blue\\
 15 &   11  &  11   & 11   & light grey\\
\hline
\end{tabular}
}
\end{description}

% ***
% BOX
% ***

\newpage
\subsection{BOX}

\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E1
\item [Format:] {\bf BOX X0,Y0, X1,Y1, X2,Y2, X3,Y3, SOLID}
\item [Usage:] {\bf BOX} draws a polygon by connecting the
               coordinate pairs 0 -> 1 -> 2 -> 3 -> 0.
               The polygon is drawn using the current drawing context
               set with SCREEN, PALETTE and PEN.
               The polygon is filled, if the parameter SOLID is 1.

\item [Remarks:] It is possible to draw bowtie shapes.
\item [Example:] Using {\bf BOX}
\begin{screenoutput}
  BOX 0,0, 160,0, 160,80, 0,80
\end{screenoutput}
\begin{tikzpicture}[thick]
\draw (4cm,0cm) -- (8cm,0cm) -- (8cm,2cm) -- (4cm,2cm) -- (4cm,0cm);
\end{tikzpicture}
\begin{screenoutput}
  BOX 0,0, 160,80, 160,0, 0,80
\end{screenoutput}
\begin{tikzpicture}[thick]
\draw (4cm,0cm) -- (8cm,2cm) -- (8cm,0cm) -- (4cm,2cm) -- (4cm,0cm);
\end{tikzpicture}
\begin{screenoutput}
  BOX 0,0, 160,0, 140,80, 20,80
\end{screenoutput}
\begin{tikzpicture}[thick]
\draw (5cm,0cm) -- (7cm,0cm) -- (8cm,2cm) -- (4cm,2cm) -- (5cm,0cm);
\end{tikzpicture}
\end{description}

% *****
% BSAVE
% *****

\newpage
\subsection{BSAVE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$10
\item [Format:] {\bf BSAVE filename ,P start TO end
                [,B bank] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf BSAVE}Â ("Binary SAVE") saves a memory range to
   a file of type PRG.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}
   If the first character of the filename is an at-sign '@' it
   is interpreted as a "save and replace" operation. It is dangerous
   to use this replace option on drives 1541 and 1571, because they
   contain the notorious "save and replace bug" in their DOS.

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf start} is the first address, where the saving begins.
   It becomes also the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf end} Is the address, where the saving stops.
   {\bf end-1} is the last address to be used for saving.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The length of the file is {\bf end - start + 2}.

\item [Example:] Using {\bf BSAVE}
\begin{screenoutput}
  BSAVE "ML DATA", P 32768 TO 33792, B0, U9
  BSAVE "SPRITES", P 1536 TO 2058
  BSAVE "ML ROUTINES", B1, P(DEC("9000")) TO (DEC("A000"))
  BSAVE (FN$), B(BA%), P(PA) TO (PE), U(UN%)
\end{screenoutput}
\end{description}

% ****
% BUMP
% ****

\newpage
\subsection{BUMP}

\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$CE \$03
\item [Format:] {\bf b = BUMP(type)}
\item [Usage:]  The {\bf BUMP} function can be used to detect
               sprite-sprite (type=1) or sprite-data (type=2) collisions.
               the return value {\bf b}Â is a 8 bit mask with
               1 bit per sprite. The bit position corresponds with the
               sprite number.
               Eachs bit set in the return value indicates, that the
               sprite for this postion was involved in a collision
               since the last call of {\bf BUMP}.
               Calling {\bf BUMP} resets the collision mask, so you
               get always a summary of collisions encountered since
               the last call of {\bf BUMP}.

\item [Remarks:] It is possible to detect multiple collisions,
               but you need to evaluate sprite coordinates then
               to detect which sprite collided with which one.

\item [Example:] Using {\bf BUMP}
\begin{screenoutput}
  S% = BUMP(1) : REM SPRITE-SPRITE COLLISION
  IF (S% AND 6) = 6) THEN PRINT "SPRITE 1 & 2 COLLISION"

  S% = BUMP(2) : REM SPRITE-DATA COLLISION
  IF (S% <> 0) THEN PRINT "SOME SPRITE HIT DATA REGION"
\end{screenoutput}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{|R{12mm}|R{12mm}|l|}
\hline
 sprite  & return & mask \\
\hline
  0 &    1  & 0000 0001 \\
  1 &    2  & 0000 0010 \\
  2 &    4  & 0000 0100 \\
  3 &    8  & 0000 1000 \\
  4 &   16  & 0001 0000 \\
  5 &   32  & 0010 0000 \\
  6 &   64  & 0100 0000 \\
  7 &  128  & 1000 0000 \\
\hline
\end{tabular}
}
\end{description}

% *******
% BVERIFY
% *******

\newpage
\subsection{BVERIFY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$28
\item [Format:] {\bf BVERIFY filename [,P address]
                [,B bank] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf BVERIFY}Â ("Binary VERIFY") compares a memory range to
   a file of type PRG.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}

   {\bf bank} specifies the RAM bank to be used.
   If not specified the current bank, as set with the last
   {\bf BANK} statement, will be used.

   {\bf address} is the address, where the comparison begins.
   If the parameter P is omitted, it is the load address,
   that is stored in the first two bytes of the PRG file.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   {\bf BVERIFY} can only test for equality. It gives no information
   about the number or position of different valued bytes.
   In direct mode the command exits either with the message {\bf OK}
   or with {\bf VERIFY ERROR}. In program mode a {\bf VERIFY ERROR}
   either stops execution or enters the {\bf TRAP} error handler,
   if active.

\item [Example:] Using {\bf BVERIFY}
\begin{screenoutput}
  BVERIFY "ML DATA", P 32768, B0, U9
  BVERIFY "SPRITES", P 1536
  BVERIFY "ML ROUTINES", B1, P(DEC("9000"))
  BVERIFY (FN$), B(BA%), P(PA), U(UN%)
\end{screenoutput}
\end{description}

% *******
% CATALOG
% *******

\newpage
\subsection{CATALOG}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0C
\item [Format:] {\bf CATALOG [filepattern] [,R] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf CATALOG}Â command prints a listing
   of the specified disk.

   The {\bf R} (Recoverable) parameter includes files in the
   directory, which are flagged as deleted but are still
   recoverable.

   {\bf filepattern} is either a quoted string, e.g. {\bf "da*"} or
   a string expression in parentheses, e.g. {\bf (DI\$)}

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The command {\bf CATALOG} is a synonym for {\bf DIRECTORY}
   or {\bf DIR} and produces the same listing.
   The {\bf filepattern} can be used to restrict the listing.
   The wildcard characters '*' and '?' may be used.
   Adding a ",T=" to the pattern string, with T specifying
   a filetype P,S,U or R (for PRG,SEQ,USR,REL) restricts the
   output to that filetype.

\item [Example:] Using {\bf CATALOG}
\begin{screenoutput}
CATALOG
  0 "BLACK SMURF     " BS  2A
508 "STORY PHOBOS"         SEQ
27  "C8096"                PRG
25  "C128"                 PRG
104 BLOCKS FREE.

DIRECTORY "*,T=S"
  0 "BLACK SMURF     " BS  2A
508 "STORY PHOBOS"         SEQ
104 BLOCKS FREE.
\end{screenoutput}
\end{description}

% ******
% CHANGE
% ******

\newpage
\subsection{CHANGE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0C
\item [Format:] {\bf CHANGE "find" TO "replace" [,from-to]}
\item [Usage:]  {\bf CHANGE} is an editor command and can be used
                in direct mode only. It searches the line range
                if specified or the whole BASIC program else.
                At each occurence of the "find string" the line is
                listed and the user prompted for an action: \\
                'Y' <RETURN> do the change and find next string \\
                'N' <RETURN> do {\bf not} change and find next string \\
                '*' <RETURN> change this and all following matches \\
                    <RETURN> exit command, don't change.
\item [Remarks:] Instead of the quote (") each other character may be used
                 as delimiter for the findstring and replacestring.
                 Using the quote as delimiter finds text strings, that are
                 not tokenized and therefore not part of a keyword. \\
                 \screentext{CHANGE "LOOP" TO "OOPS"} will not find
                 the BASIC keyword \screentext{LOOP}, because the
                 keyword is stored as token and not as text.
                 However \screentext{CHANGE \&LOOP\& TO \&OOPS\&} will
                 find and replace it (probably spoiling the program).


\item [Example:] Using {\bf CHANGE}
\begin{screenoutput}
CHANGE "XX$" TO "UU$", 2000-2700
CHANGE &IN& TO &OUT&
\end{screenoutput}
\end{description}

% ****
% CHAR
% ****

\newpage
\subsection{CHAR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E0
\item [Format:] {\bf CHAR column, row, height, width, direction, string
                [, address of character set]}
\item [Usage:]  {\bf CHAR} is used to display text on a graphic screen.
                It can be used for all resolutions.

                {\bf column} is the start position of the output
                in horizontal direction.
                One column is 8 pixels wide, so a screen width of 320
                has a column range 0 -> 39, while a width of 640
                has a range of 0 -> 79.

                {\bf row} is the start position of the output
                in vertical direction. Other than column, its unit is
                pixel with top row having the value 0.

                {\bf height}Â is a factor applied to the vertical
                size of the characters. 1 is normal size (8 pixels)
                2 is double size (16 pixels), etc.

                {\bf widht}Â is a factor applied to the horizontal
                size of the characters. 1 is normal size (8 pixels)
                2 is double size (16 pixels), etc.

                {\bf direction} controls the printing direction: \\
                1: up     \\
                2: right  \\
                4: down   \\
                8: left

                The optional {\bf address of character set} can be used
                to select a character set different from the default
                character set at \$29800, which is the set with
                upper/lower characters.

                {\bf string}Â is a string constant or expression
                which will be printed.

\item [Remarks:]
                Control characters,
                e.g. cursor movement codes, will be ignored
                (neither printed nor interpreted).


\item [Example:] Using {\bf CHAR}
\begin{screenoutput}
CHAR 304,196, 1,1,2,  "MEGA 65"
\end{screenoutput}
will printh the text "MEGA 65" on the centre of a 640 x 400 graphic screen.
\end{description}

% ****
% CHR$
% ****

\newpage
\subsection{CHR\$}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C1
\item [Format:] {\bf CHR\$(numeric expression)}
\item [Usage:] The {\bf CHR\$} function returns a string of length 1
               using the argument to insert the character having this
               value as PETSCII code.

\item [Remarks:] The argument range is 0 -> 255, so this function may
                 also be used to insert control codes into strings.
                 Even the NULL character, with code 0, is allowed. \\
               {\bf CHR\$} is the inverse function to {\bf ASC}.
\item [Example:] Using {\bf CHR\$}
\begin{screenoutput}
10 QUOTE$   = CHR$(34)
20 ESCAPE$  = CHR$(27)
30 PRINT QUOTE$;"MEGA 65";QUOTE$ : REM PRINT "MEGA 65"
40 PRINT ESCAPE$;"Q";       : REM CLEAR TO END OF LINE
\end{screenoutput}
\end{description}

% ******
% CIRCLE
% ******

\newpage
\subsection{CIRCLE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E2
\item [Format:] {\bf CIRCLE xcentre, ycentre, radius, [,solid]}
\item [Usage:] The {\bf CIRCLE} command is a special case of
               the {\bf ELLIPSE}Â command using the same value for
               horizontal and vertical radius.

               {\bf xcentre} x coordinate of centre in pixels.

               {\bf ycentre} y coordinate of centre in pixels.

               {\bf radius}Â radius of the circle in pixels.

               {\bf solid} will fill the circle if not zero.

\item [Remarks:] The {\bf CIRCLE} command is used to draw circles on
               screens with an aspect ratio 1:1 (e.g. 320 x200
               or 640 x 400). On other resolutions (e.g. 640 x 200)
               the shape will degrade to an ellipse.

\item [Example:] Using {\bf CIRCLE}
\begin{screenoutput}
10 REM USE A 640 X 400 SCREEN
20 CIRCLE 320,200,100
30 REM DRAW CIRCLE IN THE CENTRE OF THE SCREEN
\end{screenoutput}
\end{description}

% *****
% CLOSE
% *****

\newpage
\subsection{CLOSE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A0
\item [Format:] {\bf CLOSE channel}
\item [Usage:] The {\bf CLOSE} command closes an input or output
               channel, that was established before by an {\bf OPEN}
               command.

               {\bf channel} is a value in the range 0 -> 255.

\item [Remarks:] Closing open files before the program stops is
               very important, especially for output files.
               This command flushes output buffers and
               updates directory informations on disks.
               Failing to {\bf CLOSE}  can corrupt files and disks.
               BASIC does NOT automatically close channels or files
               when the program stops.

\item [Example:] Using {\bf CLOSE}
\begin{screenoutput}
10 OPEN 2,8,2,"TEST,S,W"
20 PRINT#2,"TESTSTRING"
30 CLOSE 2 : REM OMITTING CLOSE GENERATES A SPLAT FILE
\end{screenoutput}
\end{description}

% ***
% CLR
% ***

\newpage
\subsection{CLR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$9C
\item [Format:] {\bf CLR}
\item [Usage:] The {\bf CLR} command resets all pointers, that
               are used for management of BASIC variables, arrays
               and strings. The runtime stack pointers are reset
               and the table of open channels is reset.
               A {\bf RUN} command performs {\bf CLR} automatically.

\item [Remarks:] {\bf CLR} should not be used inside loops or
               subroutines because it destroys the return address.
               After a {\bf CLR} all variables are unknown and will
               be initialized at the next usage.

\item [Example:] Using {\bf CLR}
\begin{screenoutput}
10 A=5: P$="MEGA 65"
20 CLR
30 PRINT A;P$

0
READY.
\end{screenoutput}
\end{description}

% ***
% CMD
% ***

\newpage
\subsection{CMD}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$9D
\item [Format:] {\bf CMD channel [,string]}
\item [Usage:] The {\bf CMD} command redirects the standard output
               from screen to the channel. This enables to
               print listings and directories or other screen outputs.
               It is also possible to redirect this output to a disk file
               or a modem.

               {\bf channel} must be opened by the {\bf OPEN} command.

               The optional {\bf string} will be sent to the channel
               before the redirection begins and can be used,
               for example, for printer setup escape sequences.

\item [Remarks:] The {\bf CMD} mode is stopped by a {\bf PRINT\# channel}
                 or by closing the channel with {\bf CLOSE channel}.
                 It is recommended to use a {\bf PRINT\# channel}
                 before closing, to make sure, that the output buffer
                 is flushed.

\item [Example:] Using {\bf CMD} to print a program listing:
\begin{screenoutput}
OPEN 4,4
LIST
PRINT#4
CLOSE 4
\end{screenoutput}
\end{description}

% *******
% COLLECT
% *******

\newpage
\subsection{COLLECT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F3
\item [Format:] {\bf COLLECT [,D drive] [,U unit] }
\item [Usage:]
   The {\bf COLLECT}Â command rebuilds the {\bf BAM}
   (Block Availabilty Map) deleting splat files and marking
   unused blocks as free.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   While this command is useful for cleaning the disk from
   splat files (e.g. write files, that weren't properly closed)
   it is dangerous for disks with boot blocks or random access files.
   These blocks are not associated with standard disk files
   and will therefore be marked as free too and may be overwritten
   by further disk write operations.

\item [Example:] Using {\bf COLLECT}
\begin{screenoutput}
  COLLECT
  COLLECT U9
  COLLECT D0, U9
\end{screenoutput}
\end{description}

% *********
% COLLISION
% *********

\newpage
\subsection{COLLISION}

\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$17
\item [Format:] {\bf COLLISION type [,linenumber]}
\item [Usage:]  The {\bf COLLISION} statement enables or disables
                an user programmed interrupt handler.
                A call without linenumber disables the handler,
                while a call with linenumber enables it.
                After the execution of {\bf COLLISION} with
                linenumber a sprite collision of the same type,
                as specified in the {\bf COLLISION} call, will
                interrupt the BASIC program and perform a {\bf GOSUB}
                to {\bf linenumber} which is expected to contain
                the user code for handling sprite collisions.
                This handler must give control back with a {\bf RETURN}.

                {\bf type}Â specifies the collision type for
                this interrupt handler: \\
                1 = sprite - sprite collision \\
                2 = sprite - data - collision \\
                3 = light pen

                {\bf linenumber}Â must point to a subroutine
                which holds code for handling sprite collision
                and ends with a {\bf RETURN}.

\item [Remarks:] It is possible to enable interrupt handler for
               all types, but only one can execute at any time.
               A interrupt handler cannot be interrupted by another
               interrupt handler.
               Functions like {\bf BUMP}, {\bf RSPPOS} and
               {\bf LPEN} may be used for evaluation of the sprites
               which are involved and their positions.

\item [Example:] Using {\bf COLLISION}
\begin{screenoutput}
10 COLLISION 1,70 : REM ENABLE
20 SPRITE 1,1 : MOVSPR 1,120,  0 : MOVSPR 1,0#5
30 SPRITE 2,1 : MOVSPR 2,120,100 : MOVSPR 2,180#5
40 FOR I=1 TO 50000:NEXT
50 COLLISION 1 : REM DISABLE
50 END
70 REM SPRITE <-> SPRITE INTERRUPT HANDLER
80 PRINT "BUMP RETURNS";BUMP(1)
90 RETURN: REM RETURN FROM INTERRUPT
\end{screenoutput}
\end{description}

% *****
% COLOR
% *****

\newpage
\subsection{COLOR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E7
\item [Format:] {\bf COLOR <ON|OFF>}
\item [Usage:] The {\bf COLOR} command enables or disables
               handling of the character attributes on the screen.
               If {\bf COLOR} is {\bf ON}, the screen routines
               take care for both character RAM and attribute RAM.
               E.g. if the screen is scrolled for text, the attributes
               are scrolled too, so each character keeps his attribute
               or colour. If {\bf COLOR} is {\bf OFF}, the attribute
               or colour RAM is fixed and character movement is only
               done for screen characters. This speeds up screen
               handling, if moving characters with different colours is
               not intended.
\item [Example:] \screentext{COLOR ON} - with colour/attribute handling \\
                 \screentext{COLOR OFF} - no colour/attribute handling

\end{description}

% ******
% CONCAT
% ******

\newpage
\subsection{CONCAT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$13
\item [Format:] {\bf CONCAT appendfile [,D drivea] TO
                targetfile [,D drivet] [,U unit] }
\item [Usage:]
   The {\bf CONCAT}Â (concatenation) appends the contents of
   {\bf appendfile} to the {\bf targetfile}. Afterwards {\bf targetfile}
   contains the contents of both files, while {\bf appendfile}
   remains unchanged.

   {\bf appendfile} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}

   {\bf targetfile} is either a quoted string, e.g. {\bf "safe"} or
   a string expression in parentheses, e.g. {\bf (FS\$)}

   If the disk unit has dual drives, it is possible to apply
   the {\bf CONCAT} command to files, which are stored on different
   disks. In this case, it is necessary to specify the drive\#
   for both files in the command. This is necessary too, if both
   files are stored on drive\#1.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The {\bf CONCAT} commands is executed in the DOS of the disk drive.
   Both files must exist and no pattern matching is allowed.
   Only sequential files of type {\bf SEQ} may be concatenated.

\item [Example:] Using {\bf CONCAT}
\begin{screenoutput}
  CONCAT "NEW DATA" TO "ARCHIVE" ,U9
  CONCAT "ADDRESS",D0 TO "ADDRESS BOOK",D1
\end{screenoutput}
\end{description}

% ****
% CONT
% ****

\newpage
\subsection{CONT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$9A
\item [Format:] {\bf CONT}
\item [Usage:] The {\bf CONT} (continue) command is used to resume
               program execution after a break or stop caused by
               an {\bf END} or {\bf STOP} statement or by pressing
               the {\bf STOP KEY}.
               This is a useful debug tool. The BASIC program may be stopped
               and variables can be examined and even changed.
               The {\bf CONT} statement then resumes execution.
\item [Remarks:] {\bf CONT} cannot be used, if the program stops
               due to errors. Also any editing of the program
               inhibits continuation. Stopping and continuation
               can spoil the screen output or interfere with
               input/output operations.
\item [Example:] Using {\bf CONT}
\begin{screenoutput}
10 I=I+1:GOTO 10
RUN

BREAK IN 10
READY.
PRINT I
 947
CONT
\end{screenoutput}
\end{description}

% ****
% COPY
% ****

\newpage
\subsection{COPY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$13
\item [Format:] {\bf COPY source [,D drives] TO
                target [,D drivet] [,U unit] }
\item [Usage:]
   The {\bf COPY}Â copies the contents of
   {\bf source} to the {\bf target}.
   It is used to copy either single files or, by using
   wildcard characters, multiple files.

   {\bf source} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf target} is either a quoted string, e.g. {\bf "backup"} or
   a string expression in parentheses, e.g. {\bf (FS\$)}

   If the disk unit has dual drives, it is possible to copy
   files from disk to disk.
   In this case, it is necessary to specify the drive\#
   for source and target in the command. This is necessary too, if both
   files are stored on drive\#1.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The {\bf COPY} commands is executed in the DOS of the disk drive.
   It can copy all regular file types (PRG, SEQ, USR, REL).
   The source file must exist, the target file must not exist.
   if source and target are on the same disk, the target filename
   must be different fom the source file name.

\item [Example:] Using {\bf COPY}
\begin{screenoutput}
  COPY "*",D0 TO D1        :REM COPY ALL FILES
  COPY "CODES" TO "BACKUP" :REM COPY SINGLE FILE
  COPY "*.TXT" TO D1       :REM PATTERN COPY
\end{screenoutput}
\end{description}

% ***
% COS
% ***

\newpage
\subsection{COS}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$BE
\item [Format:] {\bf COS}(numeric expression)
\item [Usage:] The {\bf COS} function returns the cosine of the
               argument.
               The argument is expected in units of {\bf [radians]}.
               The result is in the range (-1.0 to +1.0)

\item [Remarks:] An argument in units of {\bf [degrees]}
                 can be converted to {\bf [radians]}
               by multiplication with $\pi/180$.
\item [Example:] Using {\bf COS}
\begin{screenoutput}
  PRINT COS(0.7)
   .764842187

  X=60:PRINT COS(X * ~ / 180)
   .500000001
\end{screenoutput}
\end{description}

% ****
% DATA
% ****

\newpage
\subsection{DATA}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$83
\item [Format:] {\bf DATA} [list of constants]
\item [Usage:] The {\bf DATA} statement is used to define constants
               which can be read by {\bf READ} statements somewhere
               in the program. All type of constants (integer, real,
               strings) are allowed, but no expressions.
               Items are separated by commas.
               Strings containing commas, colons or spaces must be put
               in quotes. \\
               A {\bf RUN}Â command initializes the data pointer
               to the first item of the first {\bf DATA} statement
               and advances it for every read item. It is in the
               responsibility of the programmer, that the type of
               the constant and the variable in the {\bf READ}
               statement match. Empty items with no constant
               between commas are allowed and will be interpreted as
               zero for numeric variables and the null string for
               string variables. \\
               The {\bf RESTORE} command may be used to set the
               data pointer to a specific line for subsequent
               readings.

\item [Remarks:] It is good programming style to put large amount of
               {\bf DATA} statements at the end of the program.
               Otherwise {\bf GOTO}Â and {\bf GOSUB}Â statements, with
               target lines lower than the current one,
               start their search for linenumber at the beginning of
               the program and have to skip through {\bf DATA}Â lines
               wasting time.
\item [Example:] Using {\bf DATA}
\begin{screenoutput}
10 READ NA$, VE
20 READ N%:FOR I=2 TO N%:READ GL(I):NEXT I
30 PRINT "PROGRAM:";NA$;"   VERSION:";VE
40 PRINT "N-POINT GAUSS-LEGENDRE FACTORS E1":
50 FOR I=2 TO N%:PRINT I;GL(I):NEXT I
30 STOP
80 DATA "MEGA 65",1.1
90 DATA 5,0.5120,0.3573,0.2760,0.2252
\end{screenoutput}
\end{description}

% ******
% DCLEAR
% ******

\newpage
\subsection{DCLEAR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$15
\item [Format:] {\bf DCLEAR [,D drive] [,U unit] }
\item [Usage:]
   The {\bf DCLEAR}Â command sends an initialize command to
   the specified unit and drive.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The DOS inside the disk unit will close all open files,
   clear all channels, free buffers and reread the BAM.
   This command should be used together with a {\bf DCLOSE}
   to make sure, that the computer and the drive agree
   on the status, otherwise strange side effects may occur.

\item [Example:] Using {\bf DCLEAR}
\begin{screenoutput}
  DCLOSE   :DCLEAR
  DCLOSE U9:DCLEAR U9
  DCLOSE U9:DCLEAR D0, U9
\end{screenoutput}
\end{description}

% ******
% DCLOSE
% ******

\newpage
\subsection{DCLOSE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0F
\item [Format:] {\bf DCLOSE [\#channel] [,U unit] }
\item [Usage:]
   The {\bf DCLOSE}Â command closes a single file or
   all files for the specified unit.

   {\bf channel}Â = channel \# assigned with the {\bf DOPEN} statement.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

   The {\bf DCLOSE}Â command is used either with a channel argument
   or a unit number, but never both.

\item [Remarks:]
   It is important to close all open files before the program ends.
   Otherwise buffers will not be freed and even worse, open write
   files will be incomplete (splat files) and no more usable.

\item [Example:] Using {\bf DCLOSE}
\begin{screenoutput}
  DCLOSE#2 :REM CLOSE FILE ASSIGNED TO CHANNEL 2
  DCLOSE U9:REM CLOSE ALL FILES OPEN ON UNIT 9
\end{screenoutput}
\end{description}

% ***
% DEC
% ***

\newpage
\subsection{DEC}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$D1
\item [Format:] {\bf DEC(string expression)}
\item [Usage:] The {\bf DEC} function returns the decimal value
               of the argument, that is written as a hex string.
               The argument range is "0000" to "FFFF" or
               0 to 65535 respectively.
               The argument must have 1-4 hex digits.

\item [Remarks:] Allowed digits in uppercase/graphics mode are: \\
                 0123456789ABCDEF and in lowercase/uppercase mode: \\
                 0123456789abcdef.

\item [Example:] Using {\bf DEC}
\begin{screenoutput}
  PRINT DEC("D000")
   53248
  POKE DEC"600"),255
\end{screenoutput}
\end{description}

% ***
% DEF
% ***

\newpage
\subsection{DEF FN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$96
\item [Format:] {\bf DEF FN name(real variable)}
\item [Usage:] The {\bf DEF} function defines a single statement
               user function with one argument of real type
               returning a real value.
               The definition must be executed before the function
               can be used in expressions. The argument is
               a dummy variable, which will be replaced by the
               argument in the function usage.

\item [Remarks:] The value of the dummy variable will not be changed
                 and the variable may be used in other context
                 without side effects.

\item [Example:] Using {\bf DEF FN}
\begin{screenoutput}
10 PD = ~ / 180
20 DEF FN CD(X)= COS(X*PD): REM COS FOR DEGREES
30 DEF FN SD(X)= SIN(X*PD): REM SIN FOR DEGREES
40 FOR D=0 TO 360 STEP 90
50 PRINT USING "###";D
60 PRINT USING " ##.##";FNCD(D);
70 PRINT USING " ##.##";FNSD(D)
80 NEXT D
RUN
  0  1.00  0.00
 90  0.00  1.00
180 -1.00  0.00
270  0.00 -1.00
360  1.00  0.00
\end{screenoutput}
\end{description}

% ******
% DELETE
% ******

\newpage
\subsection{DELETE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F7
\item [Format:] {\bf DELETE [line range]} \\
                {\bf DELETE filename [,D drive] [,U unit] [,R]}
\item [Usage:] The {\bf DELETE} command is used either to delete
               a range of lines from the BASIC program or
               to delete a disk file.

               {\bf line range} consist of the first and the last
               line to delete or a single line number.
               If the first number is omitted, the
               first BASIC line is assumed.
               The second number in the range specifier defaults
               to the last BASIC line.

   {\bf filename} is either a quoted string, e.g. {\bf "safe"} or
   a string expression in parentheses, e.g. {\bf (FS\$)}

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

   {\bf R} = Recover a previously deleted file.
   This will only work, if there were no write operations
   between deletion and recovery, which may have altered the
   contents of the file.

\item [Remarks:] The {\bf DELETE filename} command works like the
                 {\bf SCRATCH filename} command.

\item [Example:] Using {\bf DELETE}
\begin{screenoutput}
  DELETE 100      :REM DELETE LINE 100
  DELETE 240-350  :REM DELETE ALL LINES FROM 240 TO 350
  DELETE 500-     :REM DELETE FROM 500 TO END
  DELETE -70      :REM DELETE FROM START TO 70

  DELETE "DRM",U9 :REM DELETE FILE DRM ON UNIT 9
\end{screenoutput}
\end{description}

% ***
% DIM
% ***

\newpage
\subsection{DIM}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$86
\item [Format:] {\bf DIM name(limits) [,name(limits)]...}
\item [Usage:] The {\bf DIM} statement declares the shape,
               the bounds and the type of a BASIC array.
               As a declaration statement it must be executed
               only once and before any usage of the declared arrays.
               An array can have one or more dimensions.
               One dimensional arrays are often called vectors
               while two or more dimensions define a matrix.
               The lower bound of a dimension is always zero,
               while the upper bound is declared. The rules for
               variable names apply for array names too.
               There are integer arrays, real arrays and string arrays.
               It is legal to use the same identifier for scalar
               variables and array variables. The left parenthesis
               after the name identifies array names.

\item [Remarks:] Integer arrays consume 2 bytes per element,
                 real arrays 5 bytes and string arrays 3 bytes
                 for the string descriptor plus
                 the length of the string. \\
                 If an array identifier is used without previous
                 declaration, an implicit declaration of an
                 one dimensional array with limit 10 is performed.

\item [Example:] Using {\bf DIM}
\begin{screenoutput}
10 DIM A%(8)   :REM ARRAY OF 9 ELEMENTS
20 DIM XX(2,3) :REM ARRAY OF 3x4 = 12 ELEMENTS
30 FOR I=0 TO 8:A%(I)=PEEK(256+I):NEXT
40 FOR I=0 TO 2:FOR J=0 TO 3:READ XX(I,J):NEXT J,I
50 END
60 DATA 1,-2,3,-4,5,-6,7,-8,9,-10,11,-12
\end{screenoutput}
\end{description}

% *********
% DIRECTORY
% *********

\newpage
\subsection{DIRECTORY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$EE
\item [Format:] {\bf DIRECTORY [filepattern] [,R] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf DIRECTORY}Â command prints a listing
   of the specified disk and may be abbreviated to {\bf DIR}.

   The {\bf R} (Recoverable) parameter includes files in the
   directory, which are flagged as deleted but are still
   recoverable.

   {\bf filepattern} is either a quoted string, e.g. {\bf "da*"} or
   a string expression in parentheses, e.g. {\bf (DI\$)}

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The command {\bf DIRECTORY} is a synonym for {\bf CATALOG}
   or {\bf DIR} and produces the same listing.
   The {\bf filepattern} can be used to restrict the listing.
   The wildcard characters '*' and '?' may be used.
   Adding a ",T=" to the pattern string, with T specifying
   a filetype P,S,U or R (for PRG,SEQ,USR,REL) restricts the
   output to that filetype.

\item [Example:] Using {\bf DIRECTORY}
\begin{screenoutput}
DIRECTORY
  0 "BLACK SMURF     " BS  2A
508 "STORY PHOBOS"         SEQ
27  "C8096"                PRG
25  "C128"                 PRG
104 BLOCKS FREE.

DIR "*,T=S"
  0 "BLACK SMURF     " BS  2A
508 "STORY PHOBOS"         SEQ
104 BLOCKS FREE.
\end{screenoutput}
\end{description}

% ****
% DISK
% ****

\newpage
\subsection{DISK}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$40
\item [Format:] {\bf DISK command [,U unit] }
\item [Usage:]
   The {\bf DISK}Â command sends a command string to the
   specified disk unit.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

   {\bf command} is a string expression.

\item [Remarks:]
   The command string is interpreted by the disk unit
   and must be compatible to the used DOS version.
   Read the disk drive manual for possible commands.

\item [Example:] Using {\bf DISK}
\begin{screenoutput}
  DISK "I0"   :REM INITIALIZE DISK IN DRIVE 0
  DISK "U0>9" :REM CHANGE UNIT# TO 9
\end{screenoutput}
\end{description}

% *****
% DLOAD
% *****

\newpage
\subsection{DLOAD}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F0
\item [Format:] {\bf DLOAD filename [,D drive] [,U unit] }
\item [Usage:]
   The {\bf DLOAD}Â ("Disk LOAD") loads a file of type
   PRG into memory reserved for BASIC program source.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The load address, which is stored in the first two bytes
   of the file is ignored. The program is loaded into
   the BASIC memory. This enables loading of BASIC programs,
   that were saved on other computers with different memory
   configurations. After loading the program is relinked
   and ready to run or edit.
   It is possible to use DLOAD in a running program
   (Called overlay or chaining).
   Then the new loaded program replaces the current one
   and the execution starts automatically on the first line of the
   new program. Variables, arrays and strings from the current
   run are preserved and can be used by the new loaded program.

\item [Example:] Using {\bf DLOAD}
\begin{screenoutput}
  DLOAD "APOCALYPSE"
  DLOAD "MEGA TOOLS",U9
  DLOAD (FN$),U(UN%)
\end{screenoutput}
\end{description}

% ***
% DMA
% ***

\newpage
\subsection{DMA}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$23
\item [Format:] {\bf DMA command [,length, source, target, sub]}
\item [Usage:]
   The {\bf DMA}Â ("Direct Memory Access) command is the fastest method
   to manipulate memory areas using the DMA controller.

   {\bf command} 0 = copy, 1 = mix, 2 = swap, 3 = fill

   {\bf length} = number of bytes

   {\bf source}Â = 24bit address of read area or fill byte

   {\bf target} = 24bit address of write area

   {\bf sub} = sub command

\item [Remarks:]
   The {\bf DMA}Â controller has access to the whole 8 MB address range
   using 24 bit addresses.
 The block size is limited to 64K.
\item [Example:] Using {\bf DMA}
\begin{screenoutput}
DMA 3, 2000,   32,0,  2048,0 :REM FILL SCREEN WITH BLANKS
DMA 0, 2000, 2048,0, 32768,1 :REM COPY SCREEN TO $1800
\end{screenoutput}
\end{description}

% *****
% DMODE
% *****

\newpage
\subsection{DMODE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$35
\item [Format:] {\bf DMODE jam,complement,inverse,stencil,style,thick}
\item [Usage:]
   The {\bf DMODE}Â ("Display MODE") sets several parameter
   of the graphical context for drawing commands.

\ttfamily
\begin{tabular}{|l|l|}
\hline
   {\bf jam}Â        &  0 - 1 \\
   {\bf complement} &  0 - 1 \\
   {\bf inverse}    &  0 - 1 \\
   {\bf stencil}    &  0 - 1 \\
   {\bf style}      &  0 - 3 \\
   {\bf thick}      &  1 - 8 \\
\hline
\end{tabular}
\end{description}

% **
% DO
% **

\newpage
\subsection{DO}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$EB
\item [Format:] {\bf DO} ... {\bf LOOP} \\
                {\bf DO} [ <{\bf UNTIL | WHILE}>Â <logical expr.>] \\
                . . . statements [{\bf EXIT}] \\
                {\bf LOOP} [ <{\bf UNTIL | WHILE}>Â <logical expr.>]
\item [Usage:] The {\bf DO} and {\bf LOOP} keywords define
               the start and end of the most versatile BASIC loop.
               Using {\bf DO} and {\bf LOOP} alone, without any
               modifiers creates an infinite loop, that can be left
               by the {\bf EXIT} statement only. The loop can be
               controlled by adding an {\bf UNTIL} or a {\bf WHILE}
               statement after the {\bf DO} or {\bf LOOP}.

\item [Remarks:] {\bf DO} loops may be nested. An {\bf EXIT} statement
               exits the current loop only.
\item [Example:] Using {\bf DO} and {\bf LOOP}
\begin{screenoutput}
10 PW$="":DO
20 GET A$:PW$=PW$+A$
30 LOOP UNTIL LEN(PW$)>7 OR A$=CHR$(13)

10 DO : REM WAIT FOR USER DECISION
20 GET A$
30 LOOP UNTIL A$='Y' OR A$='N' OR A$='y' OR A$='n'

10 DO WHILE ABS(EPS) > 0.001
20 GOSUB 2000 : REM ITERATION SUBROUTINE
30 LOOP

10 I%=0 : REM INTEGER LOOP 1 -> 100
20 DO I%=I%+1
30 LOOP WHILE I% < 101
\end{screenoutput}
\end{description}

% *****
% DOPEN
% *****

\newpage
\subsection{DOPEN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0D
\item [Format:]
  {\bf DOPEN\# lfn, filename [,L[reclen]] [,W] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf DOPEN} command opens a file for reading, writing or
   modifying.

   {\bf lfn} = {\bf l}ogical {\bf f}ile {\bf n}umber \\
   1 <= lfn <= 127: line terminator is CR \\
   128 <= lfn <= 255: line terminator is CR LF

   {\bf L}Â indicates, that the file is a relative file, which
   is opened for read/write and random access. The reclength
   is mandatory for creating realative files. For existing
   relative files, the reclen is used as a safety check, if given.

   {\bf W}Â opens a file for write access. The file must not exist.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   \screentext{DOPEN\#} may be used to open all file types.
   The sequential file type {\bf SEQ} is default.
   The relative file type {\bf REL}Â is chosen by using the
   {\bf L} parameter.  Other file types
   must be specified in the filename, e.g. by adding ",P" to the
   filename for program files or ",U" for USR files.

   The usage of the "save-and-replace" character '@' at the
   beginning of the filename is not recommended, because many
   Commodore disk drives have a bug, that can cause data loss
   when using this feature.

\item [Example:] Using {\bf DOPEN}

\begin{screenoutput}
   DOPEN#5,"DATA",U9
   DOPEN#130,(DD$),U(UN%)
   DOPEN#3,"USER FILE,U"
   DOPEN#2,"DATA BASE",L240
   OPENN#4,"MYPROG,P" : REM OPEN PRG FILE
\end{screenoutput}
\end{description}

% ****
% DPAT
% ****

\newpage
\subsection{DPAT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$36
\item [Format:] {\bf DPAT type [,number, pattern, ...]}
\item [Usage:]
   The {\bf DPAT}Â ("Drawing PATtern") command sets pattern
   of the graphical context for drawing commands.

\ttfamily
\begin{tabular}{|l|l|}
\hline
   {\bf type}       &  0 - 63 \\
   {\bf number}     &  1 - 4 \\
   {\bf pattern}    &  0 - 255 \\
\hline
\end{tabular}
\end{description}

% *****
% DSAVE
% *****

\newpage
\subsection{DSAVE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$EF
\item [Format:] {\bf DSAVE filename [,D drive] [,U unit] }
\item [Usage:]
   The {\bf DSAVE}Â ("Disk SAVE") saves a BASIC program to
   a file of type PRG.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}
   The maximum length of the filename is 16 characters.
   If the first character of the filename is an at-sign '@' it
   is interpreted as a "save and replace" operation. It is dangerous
   to use this replace option on drives 1541 and 1571, because they
   contain the notorious "save and replace bug" in their DOS.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   The {\bf DVERIFY} can be used after {\bf DSAVE} to check,
   if the saved program on disk is identical to the program
   in memory.

\item [Example:] Using {\bf DSAVE}
\begin{screenoutput}
  DSAVE "ADVENTURE"
  DSAVE "ZORK-I",U9
  DSAVE "DUNGEON",D1,U10
\end{screenoutput}
\end{description}

% *******
% DVERIFY
% *******

\newpage
\subsection{DVERIFY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$14
\item [Format:] {\bf DVERIFY filename [,D drive] [,U unit] }
\item [Usage:]
   The {\bf DVERIFY}Â ("Disk VERIFY") compares a BASIC program
   in memory with a disk file of type PRG.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (FN\$)}

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   {\bf DVERIFY} can only test for equality. It gives no information
   about the number or position of different valued bytes.
   The command exits either with the message {\bf OK}
   or with {\bf VERIFY ERROR}.

\item [Example:] Using {\bf DVERIFY}
\begin{screenoutput}
  DVERIFY "ADVENTURE"
  DVERIFY "ZORK-I",U9
  DVERIFY "DUNGEON",D1,U10
\end{screenoutput}
\end{description}

% **
% EL
% **

\newpage
\subsection{EL}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Format:] {\bf EL} is a reserved system variable
\item [Usage:]  {\bf EL} has the value of the line, where
               the latest BASIC error
               occured or the value -1 if there was no error.

This variable is typically used in a TRAP routine,
where the error line is taken from {\bf EL}.

\item [Example:] Using {\bf EL}
\begin{screenoutput}
10 TRAP 100

100 IF ER>0 AND ER<42 THEN PRINT ERR$(ER);" ERROR"
110 PRINT " IN LINE";EL
120 RESUME
\end{screenoutput}
\end{description}

% *******
% ELLIPSE
% *******

\newpage
\subsection{ELLIPSE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$30
\item [Format:] {\bf ELLIPSE xcentre, ycentre,
                xradius, yradius, [,solid]}
\item [Usage:] As the name says, it drwas an ellipse.

               {\bf xcentre} x coordinate of centre in pixels.

               {\bf ycentre} y coordinate of centre in pixels.

               {\bf xradius}Â x radius of the ellipse in pixels.

               {\bf yradius}Â y radius of the ellipse in pixels.

               {\bf solid} will fill the ellipse if not zero.

\item [Remarks:] The {\bf ELLIPSE} command is used to draw ellipses on
               screens with various resolutions.
               It can also be used to draw circles.

\item [Example:] Using {\bf ELLIPSE}
\begin{screenoutput}
10 REM USE A 640 X 400 SCREEN
20 ELLIPSE 320,200,100,150
30 REM DRAW ELLIPSE IN THE CENTRE
\end{screenoutput}
\end{description}

% ****
% ELSE
% ****

\newpage
\subsection{ELSE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$D5
\item [Format:] {\bf IF expression THEN true clause ELSE false clause}
\item [Usage:] The {\bf ELSE} keyword is part of an {\bf IF}
               statement.

               {\bf expression} is a logical or numeric expression.
               A numerical expression is evaluated as {\bf FALSE}
               if the value is zero and {\bf TRUE} for any non zero
               value.

               {\bf true clause} are one or more statements starting
               directly after {\bf THEN} on the same line.
               A linenumber after {\bf THEN} performs a
               {\bf GOTO} to that line.

               {\bf false clause} are one or more statements starting
               directly after {\bf ELSE} on the same line.
               A linenumber after {\bf ELSE} performs a
               {\bf GOTO} to that line.

\item [Remarks:]
               The standard {\bf IF ... THEN ... ELSE} structure
               is restricted to a single line. But the {\bf true clause}
               or {\bf false clause} may be expanded to several lines
               using a compound statement bracketed with the keywords
               {\bf BEGIN} and {\bf BEND}.
\item [Example:]
                Using {\bf ELSE}
\begin{screenoutput}
10 IF V < 0 THEN PRINT RED$;:ELSE PRINT BLACK$;
20 PRINT V : REM PRINT NEGATIVE NUMBERS IN RED
30 INPUT "END PROGRAM:(Y/N)";A$
40 IF A$="Y" THEN END
50 IF A$="N" THEN 10:ELSE 30

\end{screenoutput}
\end{description}


% ***
% END
% ***

\newpage
\subsection{END}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$80
\item [Format:] {\bf END}
\item [Usage:] The {\bf END} statement ends the execution
               of the BASIC program. The {\bf READY.} prompt
               appears and the computer goes into direct mode
               waiting for keyboard input.

\item [Remarks:]
               {\bf END} does {\bf not} clear channels or close files.
               Also variable definitions are still valid after {\bf END}.
               The program may be continued with the {\bf CONT}
               statement. After executing the very last line of the
               program {\bf END} is executed automatically.


\item [Example:]
                Using {\bf END}
\begin{screenoutput}
10 IF V < 0 THEN END : REM NEGATIVE NUMBERS END THE PROGRAM
20 PRINT V
\end{screenoutput}
\end{description}

% ********
% ENVELOPE
% ********

\newpage
\subsection{ENVELOPE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$0A
\item [Format:] {\bf ENVELOPE n, [attack,decay,sustain,release,
                waveform,pw]}
\item [Usage:] The {\bf ENVELOPE} command is used to define
               the parameters for the synthesis of a musical
               instrument.

      {\bf n} = envelope slot (0 -> 9)

      {\bf attack} = attack rate (0 -> 15)

      {\bf decay} = decay rate (0 -> 15)

      {\bf sustain} = sustain rate (0 -> 15)

      {\bf release} = release rate (0 -> 15)

      {\bf waveform} = (0:triangle, 1:sawtooth, 2:square/pulse, 3:noise,
                       4:ring modulation)

      {\bf pw} = pulse width (0 -> 4095) for waveform = pulse.

               There are 10 slots for storing tunes,
               preset with following values:

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{*{7}{|R{9mm}}|l|}
\hline
 n  & A & D & S & R & WF & PW & Instrument \\
\hline
  0 & 0 &  9 &  0 &  0 &  2 &  1536  &        piano \\
  1 & 12&  0 & 12 &  0 &  1 &        &     accordion \\
  2 & 0 &  0 & 15 &  0 &  0 &        &      calliope \\
  3 & 0 &  5 &  5 &  0 &  3 &        &      drum \\
  4 & 9 &  4 &  4 &  0 &  0 &        &      flute \\
  5 & 0 &  9 &  2 &  1 &  1 &        &      guitar \\
  6 & 0 &  9 &  0 &  0 &  2 &  512   &        harpsichord \\
  7 & 0 &  9 &  9 &  0 &  2 &  2048  &        organ \\
  8 & 8 &  9 &  4 &  1 &  2 &  512   &        trumpet \\
  9 & 0 &  9 &  0 &  0 &  0 &        &      xylophone \\
\hline
\end{tabular}
}
\item [Example:]
                Using {\bf ENVELOPE}
\begin{screenoutput}
10 ENVELOPE 9,10,5,10,5,2,4000:PLAY "T9"
20 VOL 8
30 TEMPO 100
40 PLAY "C D E F G A B"
50 PLAY "U5 V1 C D E F G A B"
\end{screenoutput}
\end{description}

% *****
% ERASE
% *****

\newpage
\subsection{ERASE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$2A
\item [Format:] {\bf ERASE filename [,D drive] [,U unit] [,R]}
\item [Usage:] The {\bf ERASE} command is used
               to erase a disk file.

   {\bf filename} is either a quoted string, e.g. {\bf "safe"} or
   a string expression in parentheses, e.g. {\bf (FS\$)}

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

   {\bf R} = Recover a previously erased file.
   This will only work, if there were no write operations
   between erasion and recovery, which may have altered the
   contents of the file.

\item [Remarks:] The {\bf ERASE filename} command works like the
                 {\bf SCRATCH filename} command.

\item [Example:] Using {\bf ERASE}
\begin{screenoutput}
  ERASE "DRM",U9 :REM ERASE FILE DRM ON UNIT 9
  ERASE "OLD*"   :REM ERASE ALL FILES BEGINNING WTH "OLD"
\end{screenoutput}
\end{description}

% **
% ER
% **

\newpage
\subsection{ER}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Format:] {\bf ER} is a reserved system variable
\item [Usage:]  {\bf ER} has the value of the latest BASIC error
               occured or the value -1 if there was no error.

This variable is typically used in a TRAP routine,
where the error number is taken from {\bf ER}.

\item [Example:] Using {\bf ER}
\begin{screenoutput}
10 TRAP 100

100 IF ER>0 AND ER<42 THEN PRINT ERR$(ER);" ERROR"
110 RESUME
\end{screenoutput}
\end{description}

% *****
% ERR\$
% *****

\newpage
\subsection{ERR\$}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$D3
\item [Format:] {\bf ERR\$(number)}
\item [Usage:] The {\bf ERR\$} function is used to convert
               an error number to an error string.

   {\bf number} is a BASIC error number (1 -> 41).

This function is typically used in a TRAP routine,
where the error number is taken from the reserved variable {\bf ER}.

\item [Remarks:] Arguments out of range (1 -> 41) will
                 produce an 'ILLEGAL QUANTITY' error.

\item [Example:] Using {\bf ERR\$}
\begin{screenoutput}
10 TRAP 100

100 IF ER>0 AND ER<42 THEN PRINT ERR$(ER);" ERROR"
110 RESUME
\end{screenoutput}
\end{description}

% ****
% EXIT
% ****

\newpage
\subsection{EXIT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FD
\item [Format:] {\bf EXIT}
\item [Usage:] The {\bf EXIT} exits the current {\bf DO .. LOOP}
               and continues execution at the first
               statement after the next {\bf LOOP} statement.

\item [Remarks:] In nested loops {\bf EXIT} exits only one loop
               continuing executing in the next outer loop
               if there is one.
\item [Example:] Using {\bf EXIT}
\begin{screenoutput}
10 DO
20 INPUT "ENTER YOUR AGE";AGE%
30 IF AGE% < 18 THEN EXIT
40 INPUT "ENTER YOUR CREDIT CARD #";CR$
50 LOOP UNTIL LEN(CR$) = 12
60 IF AGE% >= 18 THEN GOSUB 1000:REM VALIDATE CREDIT CARD
70 IF AGE% <  18 THEN PRINT "TOO YOUNG":END
\end{screenoutput}
\end{description}

% ***
% EXP
% ***

\newpage
\subsection{EXP}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$BD
\item [Format:] {\bf EXP}(numeric expression)
\item [Usage:] The {\bf EXP} (EXPonential function) computes
               the value of the mathematical constant
               Euler's number {\bf e = 2.71828183}
              Â raised to the power of the
               argument.

\item [Remarks:] An argument greater than 88 produces
                 an OVERFLOW ERROR:
\item [Example:] Using {\bf EXP}
\begin{screenoutput}
PRINT EXP(1)
 2.71828183

PRINT EXP(0)
 1

PRINT EXP(LOG(2))
 2
\end{screenoutput}
\end{description}

% ****
% FAST
% ****

\newpage
\subsection{FAST}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$25
\item [Format:] {\bf FAST}
\item [Usage:] The {\bf FAST} commands sets the system speed
               to maximum (3.58 MHz).
               The system default is {\bf FAST}.
               However after using {\bf SLOW} for access to
               slow devices, {\bf FAST} can be used to return
               to fast mode.

\item [Example:] Using {\bf FAST}
\begin{screenoutput}
10 SLOW
20 GOSUB 1000:REM DO SOME SLOW I/O
30 FAST
\end{screenoutput}
\end{description}

% ******
% FILTER
% ******

\newpage
\subsection{FILTER}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$03
\item [Format:] {\bf FILTER [freq, lp, bp, hp, res]}
\item [Usage:] The {\bf FILTER} command sets
               the parameters for soundfilter.

      {\bf freq} = filter cut off frequency (0 -> 2047)

      {\bf lp} = low pass filter (0:off, 1:on)

      {\bf bp} = band pass filter (0:off, 1:on)

      {\bf hp} = high pass filter (0:off, 1:on)

      {\bf resonance} = resonance (0 -> 15)

\item [Remarks:] Missing parameter keep their current value.
                 The effective filter is the sum of
                 of all filter settings.
                 This enables band reject and notch effects.

\item [Example:]
                Using {\bf FILTER}
\begin{screenoutput}
FILTER 1023,1,0,0,10 :REM LOW PASS
FILTER 1023,0,1,0,10 :REM BAND PASS
FILTER 1023,0,0,1,10 :REM HIGH PASS
\end{screenoutput}
\end{description}

% ****
% FIND
% ****

\newpage
\subsection{FIND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$2B
\item [Format:] {\bf FIND "string" [,from-to]}
\item [Usage:]  {\bf FIND} is an editor command and can be used
                in direct mode only. It searches the line range
                (if specified) or the whole BASIC program else.
                At each occurence of the "find string" the line is
                listed with the string highlighted.
                The <NO-SCROLL> key can be used to pause the output.

\item [Remarks:] Instead of the quote (") each other character may be used
                 as delimiter for the find string.
                 Using the quote as delimiter finds text strings, that are
                 not tokenized and therefore not part of a keyword. \\
                 \screentext{FIND "LOOP"} will not find
                 the BASIC keyword \screentext{LOOP}, because the
                 keyword is stored as token and not as text.
                 However \screentext{FIND \&LOOP\&} will
                 find it.

\item [Example:] Using {\bf FIND}
\begin{screenoutput}
FIND "XX$", 2000-2700
FIND &ER&
\end{screenoutput}
\end{description}

% **
% FN
% **

\newpage
\subsection{FN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A5
\item [Format:] {\bf FN name(numeric expression)}
\item [Usage:] The {\bf FN} functions are user defined
               functions, that accept a numeric expression as
               argument and return a real value.
               They must be defined with {\bf DEF FN} before
               the first usage.

\item [Example:] Using {\bf FN}
\begin{screenoutput}
10 PD = ~ / 180
20 DEF FN CD(X)= COS(X*PD): REM COS FOR DEGREES
30 DEF FN SD(X)= SIN(X*PD): REM SIN FOR DEGREES
40 FOR D=0 TO 360 STEP 90
50 PRINT USING "###";D
60 PRINT USING " ##.##";FNCD(D);
70 PRINT USING " ##.##";FNSD(D)
80 NEXT D
RUN
  0  1.00  0.00
 90  0.00  1.00
180 -1.00  0.00
270  0.00 -1.00
360  1.00  0.00
\end{screenoutput}
\end{description}

% ***
% FOR
% ***

\newpage
\subsection{FOR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$81
\item [Format:] {\bf FOR index=start TO end [STEP step] ... NEXT [index]}
\item [Usage:] The {\bf FOR} statement starts the definition
               of a BASIC loop with an index variable.

               The {\bf index} variable may be incremented or decremented
               by a constant value on each iteration. The default
               is to increment the variable by 1.
               The index variable must be a real variable.

               The {\bf start} value is used to initialize the index.

               The {\bf end} value is used at the end of the loop
               and controls, whether the next iteration will be started
               or the loop exited.

               The {\bf step} value defines the change applied to
               to the index variable at the end of the loop.
               Positive step values increment it, while negative values
               decrement it. It defaults to 1.0 if not specified.

\item [Remarks:] For positive increments {\bf end}Â must be greater
               or equal than {\bf start}, for negative increments
               {\bf end}Â must be less or equal than {\bf start}.

               It is bad programming style to change the value
               of the index variable inside the loop or to
               jump into or out of the loop body with {\bf GOTO}.

\item [Example:] Using {\bf FOR}
\begin{screenoutput}
10 FOR D=0 TO 360 STEP 30
20 R = D * ~ / 180
30 PRINT D;R;SIN(R);COS(R);TAN(R)
40 NEXT D

10 DIM M(20,20)
20 FOR I=0 TO 20
30 FOR J=I TO 20
40 M(I,J) = I + 100 * J
50 NEXT J,I
\end{screenoutput}
\end{description}

% **********
% FOREGROUND
% **********

\newpage
\subsection{FOREGROUND}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$39
\item [Format:] {\bf FOREGROUND colour}
\item [Usage:] The {\bf FOREGROUND} command sets the foreground colour
               (text colour) of the screen to the argument,
               which must be in the
               range 0 to 15. (See colour table).
\item [Example:] \screentext{FOREGROUND  7} - select foreground colour yellow.
\item [Colours:] {\bf Index and RGB values of colour pallette}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{*{4}{|R{1.2cm}}|l|}
\hline
 index  &   red & green & blue & colour \\
\hline
  0 &    0  &   0   &  0   & black \\
  1 &   15  &  15   & 15   & white \\
  2 &   15  &   0   &  0   & red   \\
  3 &    0  &  15   & 15   & cyan  \\
  4 &   15  &   0   & 15   & magenta\\
  5 &    0  &  15   &  0   & green \\
  6 &    0  &   0   & 15   & blue  \\
  7 &   15  &  15   &  0   & yellow\\
  8 &   15  &   6   &  0   & orange\\
  9 &   10  &   4   &  0   & brown \\
 10 &   15  &   7   &  7   & pink  \\
 11 &    5  &   5   &  5   & dark grey\\
 12 &    8  &   8   &  8   & medium grey\\
 13 &    9  &  15   &  9   & light green \\
 14 &    9  &   9   & 15   & light blue\\
 15 &   11  &  11   & 11   & light grey\\
\hline
\end{tabular}
}
\end{description}

% ***
% FRE
% ***

\newpage
\subsection{FRE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$B8
\item [Format:] {\bf FRE(mode)}
\item [Usage:] The {\bf FRE} function returns the number of free
               bytes for modes 0 and 1.

               {\bf FRE(0)} returns the number of free bytes in
               bank 0, which is used for BASIC program source.

               {\bf FRE(1)} returns the number of free bytes in
               bank 1, which is the bank for BASIC variables, arrays
               and strings. A usage of {\bf FRE(1)} also triggers the
               "garbage collection", a process, that collects
               used strings at the top of the bank, thereby
               defragmenting string memory.

               {\bf FRE(2)} returns the number of expansion
               RAM banks, that are available RAM banks above
               the standard RAM banks 0 and 1, that are used by BASIC.

\item [Example:] Using {\bf FRE}:
\begin{screenoutput}
10 PM = FRE(0)
20 VM = FRE(1)
30 EM = FRE(2)
40 PRINT PM;" FREE FOR PROGRAM"
50 PRINT VM;" FREE FOR VARIABLES"
60 PRINT EM;" EXPANSION RAM BANKS"
\end{screenoutput}
\end{description}

% ***
% GET
% ***

\newpage
\subsection{GET}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A1
\item [Format:] {\bf GET string variable}
\item [Usage:] The {\bf GET} command gets the next character
               from the keyboard queue. If the queue is empty
               a null string is assigned to the variable,
               otherwise a one character string is created
               and assigned to the string variable.
               This command does not wait for keyboard
               input, so it's useful to check for key presses
               in regular intervals or loops.

\item [Remarks:] It is syntactically OK to use {\bf GET} with
               a numerical variable, but this is dangerous,
               because hitting a non numerical key will produce
               an error message and stop the program.
               The command {\bf GETKEY} is similar, but waits
               until a key was hit.

\item [Example:] Using {\bf GET}:
\begin{screenoutput}
10 DO: GET A$: LOOP UNTIL A$ <> ""
40 IF A$ = "W" THEN 1000 :REM GO NORTH
50 IF A$ = "A" THEN 2000 :REM GO WEST
60 IF A$ = "S" THEN 3000 :REM GO EAST
70 IF A$ = "Z" THEN 4000 :REM GO SOUTH
80 IF A$ = CHR$(13) THEN 5000 :REM RETURN
90 GOTO 10
\end{screenoutput}
\end{description}

% ****
% GET#
% ****

\newpage
\subsection{GET\#}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A1 '\#'
\item [Format:] {\bf GET\# channel, list of string variables}
\item [Usage:] The {\bf GET\#} command reads as many bytes
               as necessary from the channel argument
               and assigns strings of length one to
               each variable in the list.
               This is useful to read characters or bytes from
               an input stream one by one.

\item [Remarks:] All values from 0 to 255 are valid, so this
               command can also be used to read binary data.
               A value of 0 generates a string of length 1
               containing CHR\$(0) as character value.

\item [Example:] Using {\bf GET\#}:
\begin{screenoutput}
10 OPEN 2,8,0,"$0,P"          :REM OPEN CATALOG
15 IF DS THEN PRINT DS$: STOP :REM CAN'T READ
20 GET#2,D$,D$                :REM DISCARD LOAD ADDRESS
25 DO                         :REM LINE LOOP
30 : GET#2,D$,D$              :REM DISCARD LINE LINK
35 : IF ST THEN EXIT          :REM END-OF-FILE
40 : GET#2,L$,H$              :REM FILE SIZE BYTES
45 : S=ASC(L$) + 256*ASC(H$)  :REM FILE SIZE
45 : LINE INPUT#2, F$         :REM FILE NAME
50 : PRINT S;F$               :REM PRINT FILE ENTRY
55 LOOP
60 CLOSE 2
\end{screenoutput}
\end{description}

% ******
% GETKEY
% ******

\newpage
\subsection{GETKEY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A1 \$F9 (GET token and KEY token)
\item [Format:] {\bf GETKEY string variable}
\item [Usage:] The {\bf GETKEY} command gets the next character
               from the keyboard queue. If the queue is empty
               the program waits until a key is hit.
               Then a one character string is created
               and assigned to the string variable.

\item [Remarks:] It is syntactically OK to use {\bf GETKEY} with
               a numerical variable, but this is dangerous,
               because hitting a non numerical key will produce
               an error message and stop the program.

\item [Example:] Using {\bf GETKEY}:
\begin{screenoutput}
10 GETKEY A$ :REM WAIT AND GET CHARACTER
40 IF A$ = "W" THEN 1000 :REM GO NORTH
50 IF A$ = "A" THEN 2000 :REM GO WEST
60 IF A$ = "S" THEN 3000 :REM GO EAST
70 IF A$ = "Z" THEN 4000 :REM GO SOUTH
80 IF A$ = CHR$(13) THEN 5000 :REM RETURN
90 GOTO 10
\end{screenoutput}
\end{description}

% ****
% GO64
% ****

\newpage
\subsection{GO64}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$CB \$36 \$34 (GO token and 64 )
\item [Format:] {\bf GO64}
\item [Usage:] The {\bf GO64} command switches the
               computer to the C64 compatible mode.
               In direct mode a security prompt
               "ARE YOU SURE?" is printed, which must
               be responded with 'Y' to continue.

\item [Example:] Using {\bf GO64}:
\begin{screenoutput}
GO64
ARE YOU SURE?
\end{screenoutput}
\end{description}

% *****
% GOSUB
% *****

\newpage
\subsection{GOSUB}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$8D
\item [Format:] {\bf GOSUB line}
\item [Usage:] The {\bf GOSUB} (GOto SUBroutine)
               command continues program
               execution at the given BASIC line number,
               saving the current BASIC program counter
               and line number on the runtime stack.
               This enables the resume of the execution after
               the {\bf GOSUB} statement, once a {\bf RETURN}
               statement in the called subroutine was executed.
               Calls to subroutines via {\bf GOSUB} may be nested
               but the end of the subroutine code must always
               be a {\bf RETURN}. Otherwise a stack overflow
               may occur.

\item [Remarks:] Unlike other programming languages, this BASIC
               version does not support arguments or local
               variables for subroutines. \\
               Programs can be optimzed by grouping subroutines
               at the beginning of the program source. The
               {\bf GOSUB} calls will then have low line numbers
               with only few digits to decode. Also the subroutines
               will be found faster, because the search for subroutines
               starts very often at the start of the program.
\item [Example:] Using {\bf GOSUB}:
\begin{screenoutput}
 10 GOTO 100 :REM TO MAIN PROGRAM
 20 REM *** SUBROUTINE DISK STATUS CHECK ***
 30 DD=DS:IF DD THEN PRINT "DISK ERROR";DS$
 40 RETURN
 50 REM *** SUBROUTINE PROMPT Y/N ***
 60 DO:INPUT "CONTINUE (Y/N)";A$
 70 LOOP UNTIL A$="Y" OR A$="N"
 80 RETURN
 90 *** MAIN PROGRAM ***
100 DOPEN#2,"BIG DATA"
110 GOSUB 30: IF DD THEN DCLOSE#2:GOSUB 60:REM ASK
120 IF A$="N" THEN STOP
130 GOTO 100: REM RETRY
\end{screenoutput}
\end{description}

% ****
% GOTO
% ****

\newpage
\subsection{GOTO}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$89 (GOTO) or \$CB \$A4 (GO TO)
\item [Format:] {\bf GOTO line} \\
                {\bf GO TO line}
\item [Usage:] The {\bf GOTO}
               command continues program
               execution at the given BASIC line number.
               The {\bf GOTO}Â command written as a single
               word executes faster than the {\bf GO TO} command.

\item [Remarks:] The new line number will be searched by scanning
               the BASIC source linearly upwards. If the target
               line number is higher than the current one, the
               search starts from the current line upwards.
               If the target line number is lower, the search starts
               from the start of the program.
               Knowing this mechanism it is possible to optimze
               the runtime by grouping often used targets at the
               start of the program.

\item [Example:] Using {\bf GOTO}:
\begin{screenoutput}
 10 GOTO 100 :REM TO MAIN PROGRAM
 20 REM *** SUBROUTINE DISK STATUS CHECK ***
 30 DD=DS:IF DD THEN PRINT "DISK ERROR";DS$
 40 RETURN
 50 REM *** SUBROUTINE PROMPT Y/N ***
 60 DO:INPUT "CONTINUE (Y/N)";A$
 70 LOOP UNTIL A$="Y" OR A$="N"
 80 RETURN
 90 *** MAIN PROGRAM ***
100 DOPEN#2,"BIG DATA"
110 GOTO 30: IF DD THEN DCLOSE#2:GOTO 60:REM ASK
120 IF A$="N" THEN STOP
130 GOTO 100: REM RETRY
\end{screenoutput}
\end{description}

% *******
% GRAPHIC
% *******

\newpage
\subsection{GRAPHIC}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$DE
\item [Format:] {\bf GRAPHIC CLR}
\item [Usage:] The {\bf GRAPHIC CLR}
               command initializes the BASIC graphic system.
               It clears the graphics memory and screen and sets
               all parameters of the graphics context to the
               default values.

\item [Remarks:] A second form of the {\bf GRAPHIC}Â command,
               which serves as an interface to internal
               subroutines may be added later.

\item [Example:] Using {\bf GRAPHIC}:
\begin{screenoutput}
 10 GRAPHIC CLR         :REM INITIALIZE
 20 SCREEN DEF 1,1,1,2  :REM 640 X 400 X 2
 30 SCREEN SET 1,1      :REM VIEW IT
 40 SCNCLR 0            :REM CLEAR SCREEN
 50 LINE 50,50,590,350  :REM DRAW LINE
\end{screenoutput}
\end{description}

% ******
% HEADER
% ******

\newpage
\subsection{HEADER}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F1
\item [Format:] {\bf HEADER diskname [,Iid] [,D drive] [,U unit] }
\item [Usage:]
   The {\bf HEADER}Â command is used to format or clear a diskette
   or disk.

   {\bf diskname} is either a quoted string, e.g. {\bf "data"} or
   a string expression in parentheses, e.g. {\bf (DN\$)}
   The maximum length of the diskname is 16 characters.

   {\bf drive}Â = drive \# in dual drive disk units. \\
   The drive \# defaults to 0 and can be omitted on single drive units
   like the 1581, 1571 or 1541 series.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

\item [Remarks:]
   For new diskettes or disks, which are not already formatted
   it is absolutely necessary to specify the disk ID with the
   parameter {\bf Iid}. This switches the format command to the
   full format, which writes sector IDs and erases all contents.
   This will need some time, because every block on the disk will
   be written. \\
   If the {\bf Iid} parameter is omitted, a quick format will
   be performed. This is only possible, if the disk is formatted
   already. A quick format writes a new disk name and clears the
   block allocation map, marking all blocks as free.
   The disk ID is not changed, the blocks are not overwritten,
   so contents may be recovered with the {\bf ERASE R}Â command.

\item [Example:] Using {\bf HEADER}
\begin{screenoutput}
  HEADER "ADVENTURE",IBS
  HEADER "ZORK-I",U9
  HEADER "DUNGEON",D1,U10
\end{screenoutput}
\end{description}

% ****
% HELP
% ****

\newpage
\subsection{HELP}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$EA
\item [Format:] {\bf HELP}
\item [Usage:]
   When the BASIC program stops due to an error,
   the {\bf HELP}Â command can be used to list the erroneous line
   and highlight the statement, that caused the error stop.

\item [Remarks:]
      {\bf HELP} displays BASIC errors. For errors in disk
      I/O one should print the disk status variable {\bf DS}
      or the disk status string {\bf DS\$}.

\item [Example:] Using {\bf HELP}
\begin{screenoutput}
10 A=1.E20
20 B=A+A:C=EXP(A):PRINT A,B,C
RUN

?OVERFLOW ERROR IN 20
READY.
HELP

20 B=A+A:C=EXP(A):PRINT A,B,C
\end{screenoutput}
The erroneous statement is highlighted or underlined like: \\
20 B=A+A:\underline{C=EXP(A):PRINT A,B,C}
\end{description}

% *****
% HEX\$
% *****

\newpage
\subsection{HEX\$}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$D2
\item [Format:] {\bf HEX\$(numeric expression)}
\item [Usage:] The {\bf HEX\$} function returns a four
               character string in hexadecimal notation
               converted from the argument.
               The argument must be in the range 0 -> 65535
               corresponding to the hex numbers 0000 -> FFFF.

\item [Remarks:] If real numbers are used as arguments, the
                 fractional part will be cut off, not rounded.

\item [Example:] Using {\bf HEX\$}:
\begin{screenoutput}
PRINT HEX$(10),HEX$(100),HEX$(1000.9)
000A      0064      03E8
\end{screenoutput}
\end{description}

% *********
% HIGHLIGHT
% *********

\newpage
\subsection{HIGHLIGHT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$39
\item [Format:] {\bf HIGHLIGHT colour}
\item [Usage:] The {\bf HIGHLIGHT} command sets the colour
               to be used for the "highlight" text attribute.
               The colour index must be in the
               range 0 to 15. (See colour table).
\item [Remarks:] The highlight text attribute is used to mark text
               in listings generated by the {\bf HELP FIND CHANGE}
               commands.
\item [Example:] \screentext{HIGHLIGHT  7} - select highlight colour yellow.
\item [Colours:] {\bf Index and RGB values of colour pallette}

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{*{4}{|R{1.2cm}}|l|}
\hline
 index  &   red & green & blue & colour \\
\hline
  0 &    0  &   0   &  0   & black \\
  1 &   15  &  15   & 15   & white \\
  2 &   15  &   0   &  0   & red   \\
  3 &    0  &  15   & 15   & cyan  \\
  4 &   15  &   0   & 15   & magenta\\
  5 &    0  &  15   &  0   & green \\
  6 &    0  &   0   & 15   & blue  \\
  7 &   15  &  15   &  0   & yellow\\
  8 &   15  &   6   &  0   & orange\\
  9 &   10  &   4   &  0   & brown \\
 10 &   15  &   7   &  7   & pink  \\
 11 &    5  &   5   &  5   & dark grey\\
 12 &    8  &   8   &  8   & medium grey\\
 13 &    9  &  15   &  9   & light green \\
 14 &    9  &   9   & 15   & light blue\\
 15 &   11  &  11   & 11   & light grey\\
\hline
\end{tabular}
}
\end{description}

% **
% IF
% **

\newpage
\subsection{IF}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$8B
\item [Format:] {\bf IF expression THEN true clause ELSE false clause}
\item [Usage:] The {\bf IF} keyword starts a conditional execution
               statement.

               {\bf expression} is a logical or numeric expression.
               A numerical expression is evaluated as {\bf FALSE}
               if the value is zero and {\bf TRUE} for any non zero
               value.

               {\bf true clause} are one or more statements starting
               directly after {\bf THEN} on the same line.
               A linenumber after {\bf THEN} performs a
               {\bf GOTO} to that line.

               {\bf false clause} are one or more statements starting
               directly after {\bf ELSE} on the same line.
               A linenumber after {\bf ELSE} performs a
               {\bf GOTO} to that line.

\item [Remarks:]
               The standard {\bf IF ... THEN ... ELSE} structure
               is restricted to a single line. But the {\bf true clause}
               or {\bf false clause} may be expanded to several lines
               using a compound statement bracketed with the keywords
               {\bf BEGIN} and {\bf BEND}.
\item [Example:]
                Using {\bf IF}
\begin{screenoutput}
10 IF V < 0 THEN PRINT RED$;:ELSE PRINT BLACK$;
20 PRINT V : REM PRINT NEGATIVE NUMBERS IN RED
30 INPUT "END PROGRAM:(Y/N)";A$
40 IF A$="Y" THEN END
50 IF A$="N" THEN 10:ELSE 30

\end{screenoutput}
\end{description}

% *****
% INPUT
% *****

\newpage
\subsection{INPUT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$85
\item [Format:] {\bf INPUT [prompt <,|;>] variable list}
\item [Usage:] The {\bf INPUT} command prints an optional
               prompt string and question mark to the screen,
               flashes the cursor and waits for user input
               from the keyboard.

               {\bf prompt}Â = string expression to be printed
               as prompt. It may be omitted. \\
               If the separator between prompt and variable list
               is a comma, the cursor is placed directly after
               the prompt. If the separator is a semicolon,
               a question mark and a space is added to the prompt.

               {\bf variable list} = list of one or more
               variables, that receive the input.

               The input will be processed after the user hits RETURN.

\item [Remarks:] The user must take care to enter the correct
               type of input matching variable types.
               Also the number of input items must match the number
               of variables.
               Entering non numeric charcaters for integer or real
               variables will produce a TYPE MISMATCH ERROR.
               Strings for string variables have to be put in quotes
               if they contain spaces or commas. \\
               Many programs, that need a safe input routine use
               {\bf LINE INPUT} and use an own parser, in order
               to avoid program breaks by wrong user input.

\item [Example:] Using {\bf INPUT}:
\begin{screenoutput}
 10 DIM N$(100),A%(100),S$(100):
 20 DO
 30 INPUT "NAME, AGE, SEX";NA$,AG%,SE$
 40 IF NA$="" THEN 30
 50 IF NA$="END" THEN EXIT
 60 IF AG% < 18 OR AG% > 100 THEN PRINT "AGE?":GOTO 30
 70 IF SE$ <> "M" AND SE$ <> "F" THEN PRINT "SEX?":GOTO 30
 80 REM CHECK OK: ENTER INTO ARRAY
 90 N$(N)=NA$:A%(N)=AG%:S$(N)=SE$:N=N+1
100 LOOP UNTIL N=100
110 PRINT "RECEIVED";N;" NAMES"
\end{screenoutput}
\end{description}

% *******
% INPUT\#
% *******

\newpage
\subsection{INPUT\#}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$84
\item [Format:] {\bf INPUT\# chnannel, variable list}
\item [Usage:] The {\bf INPUT\#} command reads a record
               from an input device, e.g. a disk file
               or a RS232 device and assigns the read data
               to the variables in the list.

               {\bf channel}Â = channel number assigned
               by a {\bf DOPEN} or {\bf OPEN} command.

               {\bf variable list} = list of one or more
               variables, that receive the input.

               The input record must be terminated by a
               RETURN character and must be not longer than
               the input buffer (160 characters).

\item [Remarks:] The type and number of data in a record must
               match the variable list.
               Reading non numeric charcaters for integer or real
               variables will produce a FILE DATA ERROR.
               Strings for string variables have to be put in quotes
               if they contain spaces or commas. \\
               The command {\bf LINE INPUT\#} may be used to
               read a whole record into a single string variable.

\item [Example:] Using {\bf INPUT\#}:
\begin{screenoutput}
 10 DIM N$(100),A%(100),S$(100):
 20 DOPEN#2,"DATA"
 30 FOR I=0 TO 100
 40 INPUT#2,N$(I),A%(I),S$(I)
 50 IF ST=64 THEN 80:REM END OF FILE
 60 IF DS THEN PRINT DS$:GOTO 80:REM DISK ERROR
 70 NEXT I
 80 DCLOSE#2
110 PRINT "READ";I;" RECORDS"
\end{screenoutput}
\end{description}

% *****
% INSTR
% *****

\newpage
\subsection{INSTR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$D4
\item [Format:] {\bf INSTR(haystack, needle [,start])}
\item [Usage:] The {\bf INSTR} function locates the
               position of the string expression "needle"
               in the string expression "haystack" and
               returns the index of the first occurence
               or zero, if there is no match.

               The string expression {\bf haystack}
               is searched for the occurence of the
               string expression
               {\bf needle}.

               The optional argument {\bf start} is an integer
               expression, which defines the starting position
               for the search in {\bf haystack}. If not present
               it defaults to one.

\item [Remarks:] If either string is empty or there is no match
               the function returns zero.

\item [Example:] Using {\bf INSTR}:
\begin{screenoutput}
 I = INSTR("ABCDEF","CD")       : REM I = 3
 I = INSTR("ABCDEF","XY")       : REM I = 0
 I = INSTR("ABCDEF","E",3)      : REM I = 5
 I = INSTR("ABCDEF","E",6)      : REM I = 0
 I = INSTR(A$+B$,C$)
\end{screenoutput}
\end{description}

%****
% INT
%****

\newpage
\subsection{INT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$B5
\item [Format:] {\bf INT(numeric expression)}
\item [Usage:] The {\bf INT} function searches the greatest
               integer value, that is less or equal to the argument
               and returns this value as a real number.
               This function is {\bf NOT} limited to the typical
               16-bit integer range (-32768 -> 32767), because
               it uses real arithmetic. The allowed range is
               therefore determined by the size of the real
               mantissas \\
               (32 bit) : (-2147483648 -> 2147483647).

\item [Remarks:] It is not necessary to use the {\bf INT}
               function for assigning real values to integer
               variables, because this conversion will be done
               implicitly, but then for the 16-bit range.

\item [Example:] Using {\bf INT}:
\begin{screenoutput}
 X  = INT(1.9)       :REM X = 1
 X  = INT(-3.1)      :REM X = -4
 X  = INT(100000.5)  :REM X = 100000
 N% = INT(100000.5)  :REM ?ILLEGAL QUANTITY ERROR
\end{screenoutput}
\end{description}

%****
% JOY
%****

\newpage
\subsection{JOY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$CF
\item [Format:] {\bf JOY(port)}
\item [Usage:] The {\bf JOY} function returns the state of the
               joystick for the selected port (1 or 2).
               Bit 7 contains the state of the fire button.
               The stick can be moved to 8 directions, which
               are numbered clockwise starting at the upper position.

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{|r|c|c|c|}
\hline
&  left  & centre & right \\
\hline
up     &  8 &    1  & 2 \\
centre &  7 &    0  & 3 \\
down   &  6 &    5  & 4 \\
\hline
\end{tabular}
}

\item [Example:] Using {\bf JOY}:
\begin{screenoutput}
 10 N = JOY(1)
 20 IF N AND 128 THEN PRINT "FIRE! ";
 30 REM                N   NE  E   SE  S   SW  W   NW
 40 ON N AND 15 GOSUB 100,200,300,400,500,600,700,800
 50 GOTO 10
100 PRINT "GO NORTH"    :RETURN
200 PRINT "GO NORTHEAST":RETURN
300 PRINT "GO EAST"     :RETURN
400 PRINT "GO SOUTHEAST":RETURN
500 PRINT "GO SOUTH"    :RETURN
600 PRINT "GO SOUTHWEST":RETURN
700 PRINT "GO WEST"     :RETURN
800 PRINT "GO NORTHWEST":RETURN
\end{screenoutput}
\end{description}

%****
% KEY
%****

\newpage
\subsection{KEY}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$F9
\item [Format:] {\bf KEY [ ON | OFF | number, string]}
\item [Usage:] The function keys can either send their keycode
               when pressed, or a string assigned to this key.
               After power up or reset this feature is activated
               and the keys have default assignments.

               {\bf KEY OFF}: switch off function key strings.
               The keys will send their character code if pressed.

               {\bf KEY ON}: switch on function key strings.
               The keys will send assigned strings if pressed.

               {\bf KEY}: list current assignments.

               {\bf KEY number, string} assigns the string to
               the key with that number.

               Default assignments:

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{|l|r|l|}
\hline
  key  & number & string \\
\hline
F1     &  1 & "GRAPHIC" \\
F2     &  2 & "DLOAD"+CHR\$(34) \\
F3     &  3 & "DIRECTORY"+CHR\$(13) \\
F4     &  4 & "SCNCLR"+CHR\$(13) \\
F5     &  5 & "DSAVE"+CHR\$(34) \\
F6     &  6 & "RUN"+CHR\$(13) \\
F7     &  7 & "LIST"+CHR\$(13) \\
F8     &  8 & "MONITOR"+CHR\$(13) \\
HELP   & 15 & "HELP"+CHR\$(13) \\
RUN    & 16 & "RUN"+CHR\$(34)+"*"+CHR\$(34)+CHR\$(13) \\
\hline
\end{tabular}
}

\item [Remarks:] The sum of the lengths of all assigned strings
                 must not exceed 240 characters.
                 Special characters like RETURN or QUOTE are entered
                 using their codes with the CHR\$(code) function.
\item [Example:] Using {\bf KEY}:
\begin{screenoutput}
 KEY ON                   :REM ENABLE  FUNCTION KEYS
 KEY OFF                  :REM DISABLE FUNCTION KEYS
 KEY                      :REM LIST ASSIGNMENTS
 KEY 2,"PRINT ~"+CHR$(14) :REM ASSIGN PRINT PI TO F2
\end{screenoutput}
\end{description}

% ******
% LEFT\$
% ******

\newpage
\subsection{LEFT\$}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C8
\item [Format:] {\bf LEFT\$(string, n)}
\item [Usage:] The {\bf LEFT\$} function returns a string
               containing the first {\bf n} characters from the
               argument {\bf string}.
               If the length of {\bf string} is equal or less than {\bf n},
               the result string will be identical to the argument string.

               {\bf string} = a string expression

               {\bf n} = a numeric expression (0 -> 255)

\item [Remarks:] Empty strings and zero lengths are legal values.

\item [Example:] Using {\bf LEFT\$}:
\begin{screenoutput}
PRINT LEFT$("MEGA-65",4)
MEGA
\end{screenoutput}
\end{description}

% ***
% LEN
% ***

\newpage
\subsection{LEN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$C3
\item [Format:] {\bf LEN(string)}
\item [Usage:] The {\bf LEN} function returns the length of the string.

               {\bf string} = a string expression

\item [Remarks:] Unprintable characters and even the NULL character
                 are counted too.

\item [Example:] Using {\bf LEN}:
\begin{screenoutput}
PRINT LEN("MEGA-65"+CHR$(13))
8
\end{screenoutput}
\end{description}

% ***
% LET
% ***

\newpage
\subsection{LET}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$88
\item [Format:] {\bf LET variable = expression}
\item [Usage:] The {\bf LET} statement is obsolete and not needed.
               Assignment to variables can be done without using
               {\bf LET}.

\item [Example:] Using {\bf LET}:
\begin{screenoutput}
LET A=5  :REM LONGER  AND SLOWER
A=5      :REM SHORTER AND FASTER
\end{screenoutput}
\end{description}

% ****
% LINE
% ****

\newpage
\subsection{LINE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E5
\item [Format:] {\bf LINE xbeg,ybeg,xend,yend}
\item [Usage:] The {\bf LINE} statement draws a line on the current
               graphics screen from the coordinate (xbeg/ybeg) to
               the coordinate (xend/yend). All currently defined
               modes and values of the graphic context are used.

\item [Example:] Using {\bf LINE}:
\begin{screenoutput}
 10 GRAPHIC CLR         :REM INITIALIZE
 20 SCREEN DEF 1,1,1,2  :REM 640 X 400 X 2
 30 SCREEN SET 1,1      :REM VIEW IT
 40 SCNCLR 0            :REM CLEAR SCREEN
 50 LINE 50,50,590,350  :REM DRAW LINE
\end{screenoutput}
\end{description}

% ****
% LIST
% ****

\newpage
\subsection{LIST}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$9B
\item [Format:] {\bf LIST [line range]} \\
\item [Usage:] The {\bf LIST} command is used to list
               a range of lines from the BASIC program.

               {\bf line range} consist of the first and the last
               line to list or a single line number.
               If the first number is omitted, the
               first BASIC line is assumed.
               The second number in the range specifier defaults
               to the last BASIC line.

\item [Remarks:] The {\bf LIST} command's output can be redirected
                 to other devices via the {\bf CMD} command.

\item [Example:] Using {\bf LIST}
\begin{screenoutput}
  LIST 100      :REM LIST LINE 100
  LIST 240-350  :REM LIST ALL LINES FROM 240 TO 350
  LIST 500-     :REM LIST FROM 500 TO END
  LIST -70      :REM LIST FROM START TO 70
\end{screenoutput}
\end{description}

% ****
% LOAD
% ****

\newpage
\subsection{LOAD}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$93
\item [Format:] {\bf LOAD filename [,U unit [,flag]]}
\item [Usage:]
   This command is obsolete in BASIC-10, where the commands
   {\bf DLOAD} and {\bf BLOAD}Â are better alternatives.

   The {\bf LOAD}Â loads a file of type
   PRG into RAM bank 0, which is also used for BASIC program source.

   {\bf filename} is either a quoted string, e.g. {\bf "prog"} or
   a string expression.

   {\bf unit} = device number on the IEC bus.
   The number is typically in the range 8-11 for disk units.
   If a variable is used, it must be put in parentheses.
   The unit \# defaults to 8.

   If {\bf flag} has a non zero value, the file is loaded to
   the address, which is read from the first two bytes of the file.
   Otherwise it is loaded to the start of BASIC memory and
   the load address in the file is ignored.

\item [Remarks:]
   This command is implemented in BASIC-10 to keep it backward
   compatible to BASIC-2.

\item [Example:] Using {\bf LOAD}
\begin{screenoutput}
  LOAD "APOCALYPSE"
  LOAD "MEGA TOOLS",9
  LOAD "*",8,1
\end{screenoutput}
\end{description}

% ******
% LOCATE
% ******

\newpage
\subsection{LOCATE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$E6
\item [Format:] {\bf LOCATE x,y}
\item [Usage:] The {\bf LOCATE} moves the graphical cursor to
               the specified position on the current graphic screen.

\item [Remarks:] The graphical cursor is not visible, it's just
                 the starting point for follow up graphics commands.
                 The current position can be examined with the
                 {\bf RDOT} function.
\item [Example:] Using {\bf LOCATE}
\begin{screenoutput}
 LOCATE 8,16     :REM set cursor to X=8 and Y=16
\end{screenoutput}
\end{description}

% ***
% LOG
% ***

\newpage
\subsection{LOG}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$BC
\item [Format:] {\bf LOG}(numeric expression)
\item [Usage:] The {\bf LOG} (LOGarithm) function computes
               the value of the natural logarithm of the argument.
               The natural logarithm uses
               Euler's number {\bf e = 2.71828183} as base,
               not the number 10 which is typically used
               in log functions on a pocket calculator.

\item [Remarks:] The log function with base 10 can be computed
                 by dividing the result by log(10).
\item [Example:] Using {\bf LOG}
\begin{screenoutput}
PRINT LOG(1)
 0

PRINT LOG(0)
 ?ILLEGAL QUANTITY ERROR

PRINT LOG(4)
 1.38629436

PRINT LOG(100) / LOG(10)
 2
\end{screenoutput}
\end{description}

% ****
% LOOP
% ****

\newpage
\subsection{LOOP}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$EC
\item [Format:] {\bf DO} ... {\bf LOOP} \\
                {\bf DO} [ <{\bf UNTIL | WHILE}>Â <logical expr.>] \\
                . . . statements [{\bf EXIT}] \\
                {\bf LOOP} [ <{\bf UNTIL | WHILE}>Â <logical expr.>]
\item [Usage:] The {\bf DO} and {\bf LOOP} keywords define
               the start and end of the most versatile BASIC loop.
               Using {\bf DO} and {\bf LOOP} alone, without any
               modifiers creates an infinite loop, that can be left
               by the {\bf EXIT} statement only. The loop can be
               controlled by adding an {\bf UNTIL} or a {\bf WHILE}
               statement after the {\bf DO} or {\bf LOOP}.

\item [Remarks:] {\bf DO} loops may be nested. An {\bf EXIT} statement
               exits the current loop only.
\item [Example:] Using {\bf DO} and {\bf LOOP}
\begin{screenoutput}
10 PW$="":DO
20 GET A$:PW$=PW$+A$
30 LOOP UNTIL LEN(PW$)>7 OR A$=CHR$(13)

10 DO : REM WAIT FOR USER DECISION
20 GET A$
30 LOOP UNTIL A$='Y' OR A$='N' OR A$='y' OR A$='n'

10 DO WHILE ABS(EPS) > 0.001
20 GOSUB 2000 : REM ITERATION SUBROUTINE
30 LOOP

10 I%=0 : REM INTEGER LOOP 1 -> 100
20 DO I%=I%+1
30 LOOP WHILE I% < 101
\end{screenoutput}
\end{description}

% ****
% LPEN
% ****

\newpage
\subsection{LPEN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$CE \$04
\item [Format:] {\bf LPEN(coordinate)}
\item [Usage:] This function requires the use of a
               CRT monitor or TV and a light pen.
               It will not work with a LCD or LED screen.
               The lightpen must be connected to port 1.

               {\bf LPEN(0)} returns the X position of the lightpen,
               the range is 60 -> 320.

               {\bf LPEN(1)} returns the Y position of the lightpen,
               the range is 50 -> 250.

\item [Remarks:] The X resolution is 2 pixel, {\bf LPEN(0)} returns
                 therefore only even numbers.
                 A bright background colour is needed to trigger
                 the lightpen. The {\bf COLLISION}Â statement may
                 be used to install an interrupt handler.

\item [Example:] Using {\bf LPEN}
\begin{screenoutput}
 PRINT LPEN(0),LPEN(1)   :REM PRINT LIGHTPEN COORDINATES
\end{screenoutput}
\end{description}

% *****
% MID\$
% *****

\newpage
\subsection{MID\$}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$CA
\item [Format:] {\bf variable\$ = MID\$(string, index, n)} \\
                {\bf MID\$(string, index, n) = string expression}
\item [Usage:]  {\bf MID\$} can be used either as a function,
                which returns a string or as a statement for
                inserting substrings into an existing string.

               {\bf string} = a string expression

               {\bf index} = start index (0 -> 255)

               {\bf n} = length of substring (0 -> 255)

\item [Remarks:] Empty strings and zero lengths are legal values.

\item [Example:] Using {\bf MID\$}:
\begin{screenoutput}
10 A$ = "MEGA-65"
20 PRINT MID$(A$,3,4)
30 MID$(A$,5,1) = "+"
40 PRINT A$
RUN
GA-6
MEGA+65
\end{screenoutput}
\end{description}

% *******
% MONITOR
% *******

\newpage
\subsection{MONITOR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FA
\item [Format:] {\bf MONITOR}
\item [Usage:]  The {\bf MONITOR} calls the machine language
                monitor program, which is mainly used for
                debugging.

\item [Remarks:] Using the {\bf MONITOR} requires knowledge
                 of the CSG4510 / 6502 / 6510 CPU and
                 the assembler language.

\item [Example:] Using {\bf MONITOR}:
\begin{screenoutput}
 MONITOR
\end{screenoutput}
\end{description}

% *****
% MOUSE
% *****

\newpage
\subsection{MOUSE}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$3E
\item [Format:] {\bf MOUSE ON [,port [,sprite [,pos]]]} \\
                {\bf MOUSE OFF}
\item [Usage:]  The {\bf MOUSE ON} command enables the mouse driver
                and connects the mouse at the specified port
                with the mouse pointer sprite.

                {\bf port} = mouse port 1, 2 (default) or 3 (both).

                {\bf sprite} = sprite number for mouse pointer (default 0).

                {\bf pos} = intial mouse position (x,y).

                The {\bf MOUSE OFF}Â command disables the mouse
                driver and frees the associated sprite.

\item [Remarks:] The "hot spot" of the mouse pointer is the upper left
                pixel of the sprite.

\item [Example:] Using {\bf MOUSE}:
\begin{screenoutput}
 REM LOAD DATA INTO SPRITE #0 BEFORE USING IT
 MOUSE ON, 1       :REM ENABLE  MOUSE WITH SPRITE #0
 MOUSE OFF         :REM DISABLE MOUSE
\end{screenoutput}
\end{description}

% ******
% MOVSPR
% ******

\newpage
\subsection{MOVSPR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$06
\item [Format:] {\bf MOVSPR sprite, x, y} \\
                {\bf MOVSPR sprite, <+|->xrel, <+|->yrel} \\
                {\bf MOVSPR sprite, angle \# speed}
\item [Usage:]  The {\bf MOVSPR} performs, depending on the argument
                format, three different tasks:

                The first form {\bf MOVSPR sprite, x, y} uses no
                signs for the arguments and sets the absolute
                position of the sprite to the screen pixel
                coordinates {\bf x} and {\bf y}.

                The second form {\bf MOVSPR sprite, <+|->xrel, <+|->yrel}
                uses signs '+' or '-' to indicate a relative
                displacement to the current position.

                The third form {\bf MOVSPR sprite, angle \# speed} does not
                set the position of sprite {\bf n}, but defines
                motion parameters. The format is recognized by putting
                a hash sign '\#' between the last two arguments.

                {\bf sprite} = sprite number

                {\bf x} = absolute screen coordinate [pixel].

                {\bf y} = absolute screen coordinate [pixel].

                {\bf xrel} = relative screen coordinate [pixel].

                {\bf yrel} = relative screen coordinate [pixel].

                {\bf angle} = direction for sprite movement [degrees].
                0 = up, 90 = right, 180 = down, 270 = left.

                {\bf speed} = speed of movement (0 -> 15).

\item [Remarks:] The "hot spot" is the upper left pixel of the sprite.

\item [Example:] Using {\bf MOVSPR}:
\begin{screenoutput}
 10 SPRITE 1,1     :REM TURN SPRITE 1 ON
 20 MOVSPR 1,50,50 :REM SET SPRITE 1 to (50,50)
 30 MOVSPR 1,45#5  :REM MOVE SPRITE 1 WITH SPEED 5 TO UPPER RIGHT
\end{screenoutput}
\end{description}

% ***
% NEW
% ***

\newpage
\subsection{NEW}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A2
\item [Format:] {\bf NEW} \\
                {\bf NEW RESTORE}
\item [Usage:]  The {\bf NEW} resets all BASIC parameters
                to their default values.
                After {\bf NEW} the maximum RAM is available
                for program and data storage.

                Because {\bf NEW} resets parameters and pointers,
                but does not physically overwrite the address
                range of a BASIC program, that was in memory
                before {\bf NEW}, it is possible to recover the
                program. If there were no {\bf LOAD}Â operations
                or editing after the {\bf NEW} command, the program
                can bes restored with the command \\
                {\bf NEW RESTORE}.
\item [Example:] Using {\bf NEW}:
\begin{screenoutput}
 NEW         :REM RESET BASIC
 NEW RESTORE :REM TRY TO RECOVER NEW'ED PROGRAM
\end{screenoutput}
\end{description}

% ****
% NEXT
% ****

\newpage
\subsection{NEXT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$82
\item [Format:] {\bf FOR index=start TO end [STEP step] ... NEXT [index]}
\item [Usage:] The {\bf NEXT} statement terminates the definition
               of a BASIC loop with an index variable.

               The {\bf index} variable may be incremented or decremented
               by a constant value {\bf step} on each iteration. The default
               is to increment the variable by 1.
               The index variable must be a real variable.

               The {\bf start} value is used to initialize the index.

               The {\bf end} value is used at the end of the loop
               and controls, whether the next iteration will be started
               or the loop exited.

               The {\bf step} value defines the change applied to
               to the index variable at the end of the loop.
               Positive step values increment it, while negative values
               decrement it. It defaults to 1.0 if not specified.

\item [Remarks:] The {\bf index} variable after {\bf NEXT} is
               optional. If no variable is specified, the variable
               for the current loop is assumed. \\
               Several consecutive {\bf NEXT}Â statements may be
               combined by specifying the indexes in a comma
               separated list. For
               \screentext{NEXT I:NEXT J:NEXT K} the statement
               \screentext{NEXT I,J,K} is equivalent.

\item [Example:] Using {\bf NEXT}
\begin{screenoutput}
10 FOR D=0 TO 360 STEP 30
20 R = D * ~ / 180
30 PRINT D;R;SIN(R);COS(R);TAN(R)
40 NEXT D

10 DIM M(20,20)
20 FOR I=0 TO 20
30 FOR J=I TO 20
40 M(I,J) = I + 100 * J
50 NEXT J,I
\end{screenoutput}
\end{description}

% ***
% NOT
% ***

\newpage
\subsection{NOT}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$A8
\item [Format:] {\bf NOT} operand
\item [Usage:]  The boolean {\bf NOT} operator performs a bitwise
                logical NOT operation on a 16 bit value.
                Integer operands are used as they are.
                Real operands are converted to a signed 16 bit integer.
                Logical operands are converted to 16 bit integer
                using \$FFFF, decimal -1 for TRUE
                and \$0000, decimal 0, for FALSE.

   \begin{verbatim}
      NOT 0  ->  1
      NOT 1  ->  0
   \end{verbatim}

\item [Remarks:] The result is of integer type.
                 If the result is used in a logical context,
                 the value of 0 is regarded as FALSE,
                 all other, nonzero values are regarded as TRUE.
\item [Example:] Using {\bf NOT}

\begin{screenoutput}
  PRINT NOT 3
  -4
  PRINT NOT 64
  -65
\end{screenoutput}

In most cases the {\bf NOT} will be used in {\bf IF} statements.

\begin{screenoutput}
   OK = C < 256 AND C >= 0
   IF (NOT OK) THEN PRINT "NOT A BYTE VALUE"
\end{screenoutput}
\end{description}

% ***
% OFF
% ***

\newpage
\subsection{OFF}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$FE \$24
\item [Format:] keyword {\bf OFF}
\item [Usage:]  {\bf OFF} is a secondary keyword used in
                combination with primary keywords like
                {\bf COLOR, KEY, MOUSE}.

\item [Remarks:] The keyword {\bf OFF} cannot be used on its own.

\item [Example:] Using {\bf OFF}

\begin{screenoutput}
  COLOR OFF :REM DISABLE SCREEN COLOUR
  KEY OFF   :REM DISABLE FUNCTION KEY STRINGS
  MOUSE OFF :REM DISABLE MOUSE DRIVER
\end{screenoutput}
\end{description}

% **
% ON
% **

\newpage
\subsection{ON}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$91
\item [Format:] {\bf ON expression GOSUB line list} \\
                {\bf ON expression GOTO line list}  \\
                 keyword {\bf ON}
\item [Usage:]  The {\bf ON}Â keyword starts
                either a computed {\bf GOSUB} or {\bf GOTO} statement.
                Dependent on the value of the expression, the target
                for the {\bf GOSUB} or {\bf GOTO} is chosen from
                the table of line addresses at the end of the statemnt.

                As a secondary keyword, {\bf ON} is used in
                combination with primary keywords like
                {\bf COLOR, KEY, MOUSE}.

                {\bf expression} is a positive numeric value.
                Real values are cut to integer.

                {\bf line list} is a comma separated list of valid
                linenumbers.

\item [Remarks:] Negative values for {\bf expression} will stop
                 the program with an error message.
                 The {\bf line list} specifies the targets for values
                 of 1,2,3,... \\
                 An expression value of zero or a value, that is greater
                 than the number of target lines will do nothing and
                 continue program execution with the next statement.

\item [Example:] Using {\bf ON}
\begin{screenoutput}
 10 COLOR ON :REM ENABLE SCREEN COLOUR
 20 KEY   ON :REM ENABLE FUNCTION KEY STRINGS
 30 MOUSE ON :REM ENABLE MOUSE DRIVER
 40 N = JOY(1):IF N AND 128 THEN PRINT "FIRE! ";
 60 REM                N   NE  E   SE  S   SW  W   NW
 70 ON N AND 15 GOSUB 100,200,300,400,500,600,700,800
 80 GOTO 40
100 PRINT "GO NORTH"    :RETURN
200 PRINT "GO NORTHEAST":RETURN
300 PRINT "GO EAST"     :RETURN
400 PRINT "GO SOUTHEAST":RETURN
500 PRINT "GO SOUTH"    :RETURN
600 PRINT "GO SOUTHWEST":RETURN
700 PRINT "GO WEST"     :RETURN
800 PRINT "GO NORTHWEST":RETURN
\end{screenoutput}
\end{description}

% ****
% OPEN
% ****

\newpage
\subsection{OPEN}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$9F
\item [Format:]
  {\bf OPEN lfn, first address [,secondary address [,filename]]}
\item [Usage:]
   The {\bf OPEN} command opens an input/output channel for
   a device.

   {\bf lfn} = {\bf l}ogical {\bf f}ile {\bf n}umber \\
   1 <= lfn <= 127: line terminator is CR \\
   128 <= lfn <= 255: line terminator is CR LF

   {\bf first address} = device number.
   For IEC devices the unit number is the primary address.
   Following primary address values are posible:

\ttfamily
{\setlength{\tabcolsep}{1mm}
\begin{tabular}{|r|l|}
\hline
  unit  & device \\
\hline
  0 & Keyboard \\
  1 & System default \\
  2 & RS232 serial connection \\
  3 & Screen \\
  4-7 & IEC printer and plotter \\
  8-31 & IEC disk drives \\
\hline
\end{tabular}
}

   The {\bf secondary address} has some special values for
   IEC disk units, 0:load, 1:save, 15:command channel.
   The values 2 -> 14 may be used for disk files.

   {\bf filename} is either a quoted string, e.g. {\bf "data"} or
   a string expression. The syntax is different to the {\bf DOPEN\#}
   command. The {\bf filename} for {\bf OPEN} includes all
   file attributes, e.g.: "0:data,s,w".

\item [Remarks:]
   For IEC disk units the usage of {\bf DOPEN#} is recommended.

   The usage of the "save-and-replace" character '@' at the
   beginning of the filename is not recommended, because many
   Commodore disk drives have a bug, that can cause data loss
   when using this feature.

\item [Example:] Using {\bf OPEN}

\begin{screenoutput}
   OPEN 4,4   :REM OPEN PRINTER
   CMD 4      :REM REDIRECT STANDARD OUTPUT TO 4
   LIST       :REM PRINT LISTING ON PRINTER DEVICE 4
   OPEN 3,8,3,"0:USER FILE,U"
   OPEN 2,9,2,"0:DATA,S,W"
\end{screenoutput}
\end{description}

% **
% OR
% **

\newpage
\subsection{OR}
\begin{description}[leftmargin=3cm,style=nextline]
\item [Token:] \$B0
\item [Format:] operand {\bf OR} operand
\item [Usage:]  The boolean {\bf OR} operator performs a bitwise
                logical OR operation on two 16 bit values.
                Integer operands are used as they are.
                Real operands are converted to a signed 16 bit integer.
                Logical operands are converted to 16 bit integer
                using \$FFFF, decimal -1 for TRUE
                and \$0000, decimal 0, for FALSE.

   \begin{verbatim}
      0 OR 0  ->  0
      0 OR 1  ->  1
      1 OR 0  ->  1
      1 OR 1  ->  1
   \end{verbatim}

\item [Remarks:] The result is of integer type.
                 If the result is used in a logical context,
                 the value of 0 is regarded as FALSE,
                 all other, nonzero values are regarded as TRUE.
\item [Example:] Using {\bf OR}

\begin{screenoutput}
  PRINT 1 OR 3
  3
  PRINT 128 OR 64
  192
\end{screenoutput}

In most cases the {\bf OR} will be used in {\bf IF} statements.

\begin{screenoutput}
   IF (C < 0 OR C > 255) THEN PRINT "NOT A BYTE VALUE"
\end{screenoutput}
\end{description}

