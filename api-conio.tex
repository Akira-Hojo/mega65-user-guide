
\subsection{conionit}
\index{conionit}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Initialises the library internal state}
\item [Syntax:] \stw{void conioinit(void)}
\item [Notes:] {This must be called before using any conio library function.}
\end{description}

\subsection{setscreenaddr}
\index{setscreenaddr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the screen RAM start address}
\item [Syntax:] \stw{void setscreenaddr(long addr);}
\item [Parameters:]
\begin{description}\item[]
\item [{\em addr}:] {The address to set as start of screen RAM}
\end{description}
\item [Notes:] {No bounds check is performed on the selected address}
\end{description}

\subsection{getscreenaddr}
\index{getscreenaddr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Returns the screen RAM start address}
\item [Syntax:] \stw{long getscreenaddr(void);}
\item [Return Value:] {The current screen RAM address start address.}
\end{description}

\subsection{setcolramoffset}
\index{setcolramoffset}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the color RAM start offset value}
\item [Syntax:] \stw{void setcolramoffset(long offset);}
\item [Parameters:]
\begin{description}\item[]
\item [{\em addr}:] {The offset from the beginning of the color RAM address (\$FF80000)}
\end{description}
\item [Notes:] {No bounds check is performed on the resulting address. Do not exceed the available Color RAM size}
\end{description}

\subsection{getcolramoffset}
\index{getcolramoffset}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Returns the color RAM start offset value}
\item [Syntax:] \stw{long getscreenaddr(void);}
\item [Return Value:] {The current color RAM start offset value.}
\end{description}

\subsection{setcharsetaddr}
\index{setcharsetaddr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the character set start address}
\item [Syntax:] \stw{void setcharsetaddr(long addr);}
\item [Parameters:]
\begin{description}\item[]
\item [{\em addr}:] {The address to set as start of character set}
\end{description}
\item [Notes:] {No bounds check is performed on the selected address}
\end{description}

\subsection{getcharsetaddr}
\index{getcharsetaddr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Returns the current character set start address}
\item [Syntax:] \stw{long getscreenaddr(void);}
\item [Return Value:] {The current character set start address.}
\end{description}

\subsection{clrscr}
\index{clrscr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Clear the text screen. }
\item [Syntax:] \stw{void clrscr(void)}
\item [Notes:] {Color RAM will be cleared with current text color}
\end{description}

\subsection{getscreensize}
\index{getscreensize}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Returns the dimensions of the text screen}
\item [Syntax:] \stw{void getscreensize(unsigned char* width, unsigned char* height)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em width}:] {Pointer to location where width will be returned}
\item [{\em height}:] {Pointer to location where height will be returned}
\end{description}
\end{description}

\subsection{setscreensize}
\index{setscreensize}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the dimensions of the text screen}
\item [Syntax:] \stw{void setscreensize(unsigned char width, unsigned char height)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em width}:] {The width in columns (40 or 80)}
\item [{\em height}:] {The height in rows (25 or 50)}
\end{description}
\item [Notes:] {Currently only 40/80 and 25/50 are accepted. Other values are ignored.}
\end{description}

\subsection{set16bitcharmode}
\index{set16bitcharmode}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets or clear the 16-bit character mode}
\item [Syntax:] \stw{void set16bitcharmode(unsigned char f)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em f}:] {Set true to set the 16-bit character mode}
\end{description}
\item [Notes:] {This will trigger a video parameter reset if HOTREG is ENABLED. See sethotregs function.}
\end{description}

\subsection{sethotregs}
\index{sethotregs}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets or clear the hot-register behavior of the VIC-IV chip.}
\item [Syntax:] \stw{void set16bitcharmode(unsigned char f)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em f}:] {Set true to enable the hotreg behavior}
\end{description}
\item [Notes:] {When this mode is ENABLED a video mode reset will be triggered when touching \$D011, \$D016, \$D018, \$D031 or the VIC-II bank bits of \$DD00. }
\end{description}

\subsection{setextendedattrib}
\index{setextendedattrib}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets or clear the VIC-III extended attributes mode to support blink, underline, bold and highlight.}
\item [Syntax:] \stw{void setextendedattrib(unsigned char f)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em f}:] {Set true to set the extended attributes mode}
\end{description}
\end{description}

\subsection{togglecase}
\index{togglecase}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Toggle the current character set case}
\item [Syntax:] \stw{void togglecase(void)}
\end{description}

\subsection{bordercolor}
\index{bordercolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the current border color}
\item [Syntax:] \stw{void bordercolor(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The color to set}
\end{description}
\end{description}

\subsection{bgcolor}
\index{bgcolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the current screen (background) color}
\item [Syntax:] \stw{void bgcolor(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The color to set}
\end{description}
\end{description}

\subsection{textcolor}
\index{textcolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the current text color}
\item [Syntax:] \stw{void textcolor(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The color to set}
\end{description}
\end{description}

\subsection{revers}
\index{revers}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the reverse attribute}
\item [Syntax:] \stw{void revers(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{highlight}
\index{highlight}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the highlight attribute}
\item [Syntax:] \stw{void highlight(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{blink}
\index{blink}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the blink attribute}
\item [Syntax:] \stw{void blink(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{underline}
\index{underline}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the underline attribute}
\item [Syntax:] \stw{void underline(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{cellcolor}
\index{cellcolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the color of a character cell}
\item [Syntax:] \stw{void cellcolor(unsigned char x, unsigned char y, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The cell X-coordinate}
\item [{\em y}:] {The cell Y-coordinate}
\item [{\em c}:] {The color to set}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{setpalbank}
\index{setpalbank}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set current text/bitmap palette bank (BTPALSEL).}
\item [Syntax:] \stw{void setpalbank(unsigned char bank)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em bank}:] {The palette bank to set. Valid values are 0, 1, 2 or 3.}
\end{description}
\item [Notes:] {Use setpalbanka to set alternate text/bitmap palette}
\end{description}

\subsection{setpalbanka}
\index{setpalbanka}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set alternate text/bitmap palette bank.}
\item [Syntax:] \stw{void setpalbanka(unsigned char bank)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em bank}:] {The palette bank to set. Valid values are 0, 1, 2 or 3.}
\end{description}
\item [Notes:] {Use setpalbank to set main text/bitmap palette}
\end{description}

\subsection{getpalbank}
\index{getpalbank}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Get selected text/bitmap palette bank.}
\item [Syntax:] \stw{unsigned char getpalbank(void)}
\item [Notes:] {Use getpalbanka to get alternate text/bitmap selected palette}
\item [Return Value:] {The current selected main text/bitmap palette bank.}
\end{description}

\subsection{getpalbanka}
\index{getpalbanka}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Get selected alternate text/bitmap palette bank.}
\item [Syntax:] \stw{unsigned char getpalbanka(void)}
\item [Notes:] {Use getpalbank to get main text/bitmap selected palette}
\item [Return Value:] {The current selected alternate text/bitmap palette bank.}
\end{description}

\subsection{setmapedpal}
\index{setmapedpal}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set maped-in palette bank at \$D100-\$D3FF.}
\item [Syntax:] \stw{void setmapedpal(unsigned char bank)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em bank}:] {The palette bank to map-in. Valid values are 0, 1, 2 or 3.}
\end{description}
\end{description}

\subsection{getmapedpal}
\index{getmapedpal}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Get maped-in  palette bank at \$D100-\$D3FF.}
\item [Syntax:] \stw{unsigned char getmapedpal(void)}
\end{description}

\subsection{setpalentry}
\index{setpalentry}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set color entry for the maped-in palette}
\item [Syntax:] \stw{void setpalentry(unsigned char c, unsigned char r, unsigned char g, unsigned char b)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The palette entry index (0-255)}
\item [{\em r}:] {The red component value}
\item [{\em g}:] {The green component value}
\item [{\em b}:] {The blue component value}
\end{description}
\item [Notes:] {Use setmapedmal to bank-in the palette to modify}
\end{description}

\subsection{fillrect}
\index{fillrect}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Fill a rectangular area with character and color value}
\item [Syntax:] \stw{void fillrect(const RECT *rc, unsigned char ch, unsigned char col)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em rc}:] {A RECT structure specifying the box coordinates}
\item [{\em ch}:] {A char code to fill the rectangle}
\item [{\em col}:] {The color to fill}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{box}
\index{box}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Draws a box with graphic characters}
\item [Syntax:] \stw{void box(const RECT *rc, unsigned char color, unsigned char style, unsigned char clear, unsigned char shadow)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em rc}:] {A RECT structure specifying the box coordinates}
\item [{\em color}:] {The color to use for the graphic characters}
\item [{\em style}:] {The style for the box borders. Can be set to BOX\_STYLE\_NONE, BOX\_STYLE\_ROUNDED, BOX\_STYLE\_INNER, BOX\_STYLE\_OUTER, BOX\_STYLE\_MID }
\item [{\em clear}:] {Set to 1 to clear the box interior with the selected color}
\item [{\em shadow}:] {Set to 1 to draw a drop shadow}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{hline}
\index{hline}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Draws an horizontal line.}
\item [Syntax:] \stw{void hline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The line start X-coordinate}
\item [{\em y}:] {The line start Y-coordinate}
\item [{\em len}:] {The line length}
\item [{\em style}:] {The style for the line. See HLINE\_ constants for available styles. }
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{vline}
\index{vline}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Draws a vertical line.}
\item [Syntax:] \stw{void vline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The line start X-coordinate}
\item [{\em y}:] {The line start Y-coordinate}
\item [{\em len}:] {The line length}
\item [{\em style}:] {The style for the line. See VLINE\_ constants for available styles. }
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{gohome}
\index{gohome}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position at home (0,0 coordinate)}
\item [Syntax:] \stw{void gohome(void)}
\end{description}

\subsection{gotoxy}
\index{gotoxy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position at X,Y coordinates}
\item [Syntax:] \stw{void gotoxy(unsigned char x, unsigned char y)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The new X-coordinate}
\item [{\em y}:] {The new Y-coordinate}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{gotox}
\index{gotox}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position X-coordinate}
\item [Syntax:] \stw{void gotox(unsigned char x)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The new X-coordinate}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{gotoy}
\index{gotoy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position Y-coordinate}
\item [Syntax:] \stw{void gotoy(unsigned char y)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em y}:] {The new Y-coordinate}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{moveup}
\index{moveup}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position up}
\item [Syntax:] \stw{void moveup(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{movedown}
\index{movedown}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position down}
\item [Syntax:] \stw{void movedown(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{moveleft}
\index{moveleft}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position left}
\item [Syntax:] \stw{void moveleft(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{moveright}
\index{moveright}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position right}
\item [Syntax:] \stw{void moveright(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{wherex}
\index{wherex}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Return the current position X coordinate}
\item [Syntax:] \stw{unsigned char wherex(void)}
\item [Return Value:] {The current position X coordinate}
\end{description}

\subsection{wherey}
\index{wherey}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Return the current position Y coordinate}
\item [Syntax:] \stw{unsigned char wherey(void)}
\item [Return Value:] {The current position Y coordinate}
\end{description}

\subsection{cputc}
\index{cputc}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a single character to screen at current position}
\item [Syntax:] \stw{void cputc(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The character to output}
\end{description}
\end{description}

\subsection{cputnc}
\index{cputnc}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output N copies of a character at current position}
\item [Syntax:] \stw{void cputnc(unsigned char count, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The character to output}
\item [{\em count}:] {The count of characters to print}
\end{description}
\end{description}

\subsection{cputhex}
\index{cputhex}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output an hex-formatted number at current position}
\item [Syntax:] \stw{void cputhex(long n, unsigned char prec)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em n}:] {The number to write}
\item [{\em prec}:] {The precision of the hex number, in digits. Leading zeros will be printed accordingly}
\end{description}
\item [Notes:] {The \$ symbol will be automatically added at beginning of string}
\end{description}

\subsection{cputdec}
\index{cputdec}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a decimal number at current position}
\item [Syntax:] \stw{void cputdec(long n, unsigned char padding, unsigned char leadingZ)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em n}:] {The number to write}
\item [{\em padding}:] {The padding space to add before number}
\item [{\em leadingZ}:] {The leading zeros to print}
\end{description}
\end{description}

\subsection{cputs}
\index{cputs}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a string at current position}
\item [Syntax:] \stw{void cputs(const unsigned char* s)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em s}:] {The string to print}
\end{description}
\item [Notes:] {No pointer check is performed.  If s is null or invalid, behavior is undefined }
\end{description}

\subsection{cputsxy}
\index{cputsxy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a string at X,Y coordinates}
\item [Syntax:] \stw{void cputsxy (unsigned char x, unsigned char y, const unsigned char* s)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The X coordinate where string will be printed}
\item [{\em y}:] {The Y coordinate where string will be printed}
\item [{\em s}:] {The string to print}
\end{description}
\item [Notes:] {No pointer check is performed.  If s is null or invalid, behavior is undefined }
\end{description}

\subsection{cputcxy}
\index{cputcxy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a single character at X,Y coordinates}
\item [Syntax:] \stw{void cputcxy (unsigned char x, unsigned char y, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The X coordinate where character will be printed}
\item [{\em y}:] {The Y coordinate where character will be printed}
\item [{\em c}:] {The character to print}
\end{description}
\end{description}

\subsection{cputncxy}
\index{cputncxy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output N copies of a single character at X,Y coordinates}
\item [Syntax:] \stw{void cputncxy (unsigned char x, unsigned char y, unsigned char count, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The X coordinate where character will be printed}
\item [{\em y}:] {The Y coordinate where character will be printed}
\item [{\em count}:] {The number of characters to output}
\item [{\em c}:] {The character to print}
\end{description}
\end{description}

\subsection{cprintf}
\index{cprintf}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Prints formatted output. \\
    Escape strings can be used to modify attributes, move cursor, etc similar to PRINT in CBM BASIC. 
    }
\item [Syntax:] \stw{unsigned char cprintf (const unsigned char* format, ...)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em format}:] {The string to output. The available escape codes are: \\
    
    \textbf{Cursor positioning} \\
    \begin{tabular}{ll}
    \textbackslash t             & Go to next tab position (multiple of 8s)            \\ 
    \textbackslash r             & Carriage Return            \\
    \textbackslash n             & New line          \\
    \end{tabular}
    
    \begin{tabular}{llll}
    \texttt{\{clr\}}   &     Clear screen      &  \texttt{\{home\}}  & Move cursor to home (top-left) \\
    \texttt{\{d\}}     &    Move cursor down   & \texttt{\{u\}}      & Move cursor up \\
    \texttt{\{r\}}     &    Move cursor right  & \texttt{\{l\}}     & Move cursor left \\
    
    \end{tabular}
    
    \textbf{Attributes} \\
    \begin{tabular}{llll}
    \texttt{\{rvson\}}  &  Reverse attribute ON   & \texttt{\{rvsoff\}} &  Reverse attribute OFF \\
    \texttt{\{blon\}}   &  Blink attribute ON     & \texttt{\{bloff\}}  &  Blink attribute OFF    \\ 
    \texttt{\{ulon\}}   &  Underline attribute ON & \texttt{\{uloff\}}  &  Underline attribute OFF \\
    \end{tabular}

    \textbf{Colors (default palette)} \\
    \begin{tabular}{llll}
    \texttt{\{blk\}}  & \texttt{\{wht\}}  &  \texttt{\{red\}} &  \texttt{\{cyan\}}  \\ 
    \texttt{\{pur\}}  & \texttt{\{grn\}}  &  \texttt{\{blu\}} &  \texttt{\{yel\}}   \\
    \texttt{\{ora\}}  & \texttt{\{brn\}}  &  \texttt{\{pink\}} & \texttt{\{gray1\}} \\
    \texttt{\{gray2\}} &  \texttt{\{lblu\}} &  \texttt{\{lgrn\}} & \texttt{\{gray3\}}

    \end{tabular}
%   \end{table}
  
    
    
    }
\end{description}
\item [Notes:] {Currently no argument replacement is done with the variable arguments.}
\end{description}

\subsection{cgetc}
\index{cgetc}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] { Waits until a character is in the keyboard buffer and returns it }
\item [Syntax:] \stw{unsigned char cgetc (void);}
\item [Return Value:] {The last character in the keyboard buffer }
\item [Notes:] {Returned values are ASCII character codes}
\end{description}

\subsection{kbhit}
\index{kbhit}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] { Returns the character in the keyboard buffer }
\item [Syntax:] \stw{unsigned char kbhit (void);}
\item [Return Value:] {The character code in the keyboard buffer,  0 otherwise. }
\item [Notes:] {Returned values are ASCII character codes}
\end{description}

\subsection{getkeymodstate}
\index{getkeymodstate}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] { 
   Return the key modifiers state.}
\item [Syntax:] \stw{unsigned char getkeymodstate(void)}
\item [Return Value:] {A byte with the key modifier state bits, 
    where bits:
   
    \begin{tabular}{lll}
    \textbf{Bit} & \textbf{Meaning} & \textbf{Constant}        \\ 
    0   & Right SHIFT State & \texttt{KEYMOD\_RSHIFT} \\
    1   & Left  SHIFT state & \texttt{KEYMOD\_LSHIFT} \\
    2   & CTRL state        & \texttt{KEYMOD\_CTRL}  \\
    3   & MEGA state        & \texttt{KEYMOD\_MEGA} \\
    4   & ALT state         & \texttt{KEYMOD\_ALT} \\
    5   & NOSCRL state      & \texttt{KEYMOD\_NOSCRL} \\
    6   & CAPSLOCK state    & \texttt{KEYMOD\_CAPSLOCK} \\
    7   & Reserved          & - \\
    \end{tabular}        
    }
\end{description}

\subsection{flushkeybuf}
\index{flushkeybuf}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Flush the keyboard buffer}
\item [Syntax:] \stw{void flushkeybuf(void)}
\end{description}

\subsection{cinput}
\index{cinput}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Get input from keyboard, printing incoming characters at current position.}
\item [Syntax:] \stw{unsigned char cinput(char* buffer, unsigned char buflen, unsigned char flags)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em buffer}:] {Target character buffer preallocated by caller}
\item [{\em buflen}:] {Target buffer length in characters, including the null character terminator}
\item [{\em flags}:] {Flags for input:  (default is accept all printable characters)
            
            \texttt{CINPUT\_ACCEPT\_NUMERIC} \\ 
            Accepts numeric characters. \\ \\
            \texttt{CINPUT\_ACCEPT\_LETTER}  \\  
            Accepts letters.  \\ \\
            \texttt{CINPUT\_ACCEPT\_SYM}  \\   
            Accepts symbols.  \\ \\
            \texttt{CINPUT\_ACCEPT\_ALL}\\
            Accepts all. Equals to \texttt{CINPUT\_ACCEPT\_NUMERIC \textbar CINPUT\_ACCEPT\_LETTER \textbar CINPUT\_ACCEPT\_SYM} \\ \\
            \texttt{CINPUT\_ACCEPT\_ALPHA} \\
            Accepts alphanumeric characters. Equals to \texttt{CINPUT\_ACCEPT\_NUMERIC \textbar CINPUT\_ACCEPT\_LETTER} \\ \\
            \texttt{CINPUT\_NO\_AUTOTRANSLATE}\\
            Disables the feature that makes cinput to autodisplay uppercase characters when standard lowercase character set is selected  and the user enters letters without the SHIFT key, that would display graphic characters instead of alphabetic ones. \\
            }
  }
\end{description}
\item [Return Value:] {Count of successfully read characters in buffer}
\end{description}
