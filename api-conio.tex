
\subsection{conionit}
\index{conionit}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Initializes the library internal state}
\item [Syntax:] \stw{void conioinit(void)}
\item [Notes:] {This must be called before using any conio library function.}
\end{description}

\subsection{setscreenaddr}
\index{setscreenaddr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the screen RAM start address}
\item [Syntax:] \stw{void setscreenaddr(long addr);}
\item [Parameters:]
\begin{description}\item[]
\item [{\em addr}:] {The address to set as start of screen RAM}
\end{description}
\item [Notes:] {No bounds check is performed on the selected address}
\end{description}

\subsection{getscreenaddr}
\index{getscreenaddr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Returns the screen RAM start address}
\item [Syntax:] \stw{long getscreenaddr(void);}
\item [Desription:] {The current screen RAM address start address.}
\end{description}

\subsection{clrscr}
\index{clrscr}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Clear the text screen. }
\item [Syntax:] \stw{void clrscr(void)}
\item [Notes:] {Color RAM will be cleared with current text color}
\end{description}

\subsection{getscreensize}
\index{getscreensize}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Returns the dimensions of the text screen}
\item [Syntax:] \stw{void getscreensize(unsigned char* width, unsigned char* height)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em width}:] {Pointer to location where width will be returned}
\item [{\em width}:] {Pointer to location where height will be returned}
\end{description}
\end{description}

\subsection{setscreensize}
\index{setscreensize}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the dimensions of the text screen}
\item [Syntax:] \stw{void setscreensize(unsigned char width, unsigned char height)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em width}:] {The width in columns (40 or 80)}
\item [{\em width}:] {The height in rows (25 or 50)}
\end{description}
\item [Notes:] {Currently only 40/80 and 25/50 are accepted. Other values are ignored.}
\end{description}

\subsection{set16bitcharmode}
\index{set16bitcharmode}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets or clear the 16-bit character mode}
\item [Syntax:] \stw{void set16bitcharmode(unsigned char f)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em f}:] {Set true to set the 16-bit character mode}
\end{description}
\end{description}

\subsection{setextendedattrib}
\index{setextendedattrib}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets or clear the VIC-III extended attributes mode to support blink, underline, bold and highlight.}
\item [Syntax:] \stw{void setextendedattrib(unsigned char f)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em f}:] {Set true to set the extended attributes mode}
\end{description}
\end{description}

\subsection{togglecase}
\index{togglecase}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Toggle the current character set case}
\item [Syntax:] \stw{void togglecase(void)}
\end{description}

\subsection{bordercolor}
\index{bordercolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the current border color}
\item [Syntax:] \stw{void bordercolor(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The color to set}
\end{description}
\end{description}

\subsection{bgcolor}
\index{bgcolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the current screen (background) color}
\item [Syntax:] \stw{void bgcolor(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The color to set}
\end{description}
\end{description}

\subsection{textcolor}
\index{textcolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the current text color}
\item [Syntax:] \stw{void textcolor(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The color to set}
\end{description}
\end{description}

\subsection{revers}
\index{revers}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the reverse attribute}
\item [Syntax:] \stw{void revers(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{highlight}
\index{highlight}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the highlight attribute}
\item [Syntax:] \stw{void highlight(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{blink}
\index{blink}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the blink attribute}
\item [Syntax:] \stw{void blink(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{underline}
\index{underline}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Enable the underline attribute}
\item [Syntax:] \stw{void underline(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em enable}:] {0 to disable, 1 to enable}
\end{description}
\item [Notes:] {Extended attributes mode must be active. See setextendedattrib.}
\end{description}

\subsection{cellcolor}
\index{cellcolor}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Sets the color of a character cell}
\item [Syntax:] \stw{void cellcolor(unsigned char x, unsigned char y, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The cell X-coordinate}
\item [{\em y}:] {The cell Y-coordinate}
\item [{\em c}:] {The color to set}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{fillrect}
\index{fillrect}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Fill a rectangular area with character and color value}
\item [Syntax:] \stw{void fillrect(const RECT *rc, unsigned char ch, unsigned char col)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em rc}:] {A RECT structure specifying the box coordinates}
\item [{\em ch}:] {A char code to fill the rectangle}
\item [{\em col}:] {The color to fill}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{box}
\index{box}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Draws a box with graphic characters}
\item [Syntax:] \stw{void box(const RECT *rc, unsigned char color, unsigned char style, unsigned char clear, unsigned char shadow)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em rc}:] {A RECT structure specifying the box coordinates}
\item [{\em color}:] {The color to use for the graphic characters}
\item [{\em style}:] {The style for the box borders. Can be set to BOX\_STYLE\_ROUNDED, BOX\_STYLE\_INNER, BOX\_STYLE\_OUTER, BOX\_STYLE\_MID }
\item [{\em clear}:] {Set to 1 to clear the box interior with the selected color}
\item [{\em shadow}:] {Set to 1 to draw a drop shadow}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{hline}
\index{hline}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Draws an horizontal line.}
\item [Syntax:] \stw{void hline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The line start X-coordinate}
\item [{\em y}:] {The line start Y-coordinate}
\item [{\em len}:] {The line length}
\item [{\em style}:] {The style for the line. See HLINE\_ constants for available styles. }
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{vline}
\index{vline}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Draws a vertical line.}
\item [Syntax:] \stw{void vline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The line start X-coordinate}
\item [{\em y}:] {The line start Y-coordinate}
\item [{\em len}:] {The line length}
\item [{\em style}:] {The style for the line. See VLINE\_ constants for available styles. }
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{gohome}
\index{gohome}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position at home (0,0 coordinate)}
\item [Syntax:] \stw{void gohome(void)}
\end{description}

\subsection{gohome}
\index{gohome}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position at X,Y coordinates}
\item [Syntax:] \stw{void gotoxy(unsigned char x, unsigned char y)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The new X-coordinate}
\item [{\em y}:] {The new Y-coordinate}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{gotox}
\index{gotox}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position X-coordinate}
\item [Syntax:] \stw{void gotox(unsigned char x)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The new X-coordinate}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{gotoy}
\index{gotoy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Set the current position Y-coordinate}
\item [Syntax:] \stw{void gotoy(unsigned char y)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em y}:] {The new Y-coordinate}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{moveup}
\index{moveup}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position up}
\item [Syntax:] \stw{void moveup(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{movedown}
\index{movedown}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position down}
\item [Syntax:] \stw{void movedown(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{moveleft}
\index{moveleft}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position left}
\item [Syntax:] \stw{void moveleft(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{moveright}
\index{moveright}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Move current position right}
\item [Syntax:] \stw{void moveright(unsigned char count)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em count}:] {The number of positions to move}
\end{description}
\item [Notes:] {No screen bounds checks are performed; out of screen behavior is undefined }
\end{description}

\subsection{wherex}
\index{wherex}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Return the current position X coordinate}
\item [Syntax:] \stw{unsigned char wherex(void)}
\item [Desription:] {The current position X coordinate}
\end{description}

\subsection{wherey}
\index{wherey}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Return the current position Y coordinate}
\item [Syntax:] \stw{unsigned char wherey(void)}
\item [Desription:] {The current position Y coordinate}
\end{description}

\subsection{cputc}
\index{cputc}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a single character to screen at current position}
\item [Syntax:] \stw{void cputc(unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The character to output}
\end{description}
\end{description}

\subsection{cputnc}
\index{cputnc}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output N copies of a character at current position}
\item [Syntax:] \stw{void cputnc(unsigned char count, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em c}:] {The character to output}
\item [{\em count}:] {The count of characters to print}
\end{description}
\end{description}

\subsection{cputhex}
\index{cputhex}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output an hex-formatted number at current position}
\item [Syntax:] \stw{void cputhex(long n, unsigned char prec)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em n}:] {The number to write}
\item [{\em prec}:] {The precision of the hex number, in digits. Leading zeros will be printed accordingly}
\end{description}
\item [Notes:] {The \$ symbol will be automatically added at beginning of string}
\end{description}

\subsection{cputdec}
\index{cputdec}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a decimal number at current position}
\item [Syntax:] \stw{void cputdec(long n, unsigned char padding, unsigned char leadingZ)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em n}:] {The number to write}
\item [{\em padding}:] {The padding space to add before number}
\item [{\em leadingZ}:] {The leading zeros to print}
\end{description}
\end{description}

\subsection{cputs}
\index{cputs}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a string at current position}
\item [Syntax:] \stw{void cputs(const char* s)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em s}:] {The string to print}
\end{description}
\item [Notes:] {No pointer check is performed.  If s is null or invalid, behavior is undefined }
\end{description}

\subsection{cputsxy}
\index{cputsxy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a string at X,Y coordinates}
\item [Syntax:] \stw{void cputsxy (unsigned char x, unsigned char y, const char* s)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em s}:] {The string to print}
\item [{\em x}:] {The X coordinate where string will be printed}
\item [{\em y}:] {The Y coordinate where string will be printed}
\end{description}
\item [Notes:] {No pointer check is performed.  If s is null or invalid, behavior is undefined }
\end{description}

\subsection{cputcxy}
\index{cputcxy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output a single character at X,Y coordinates}
\item [Syntax:] \stw{void cputcxy (unsigned char x, unsigned char y, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The X coordinate where character will be printed}
\item [{\em y}:] {The Y coordinate where character will be printed}
\item [{\em c}:] {The character to print}
\end{description}
\end{description}

\subsection{cputncxy}
\index{cputncxy}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Output N copies of a single character at X,Y coordinates}
\item [Syntax:] \stw{void cputncxy (unsigned char x, unsigned char y, unsigned char c)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em x}:] {The X coordinate where character will be printed}
\item [{\em y}:] {The Y coordinate where character will be printed}
\item [{\em count}:] {The number of characters to output}
\item [{\em c}:] {The character to print}
\end{description}
\end{description}

\subsection{cprintf}
\index{cprintf}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Prints formatted output.

    Escape strings can be used to modify attributes, move cursor,etc,
    similar to PRINT in CBM BASIC. Available escape codes:

    Cursor positioning

    \textbackslash t           Go to next tab position (multiple of 8s) \\
    \textbackslash r           Return \\
    \textbackslash n           New-line (assume \textbackslash r like in C printf)

    {clr}
\item [Syntax:] \stw{unsigned char cprintf (const unsigned char* format, ...)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em format}:] {The string to output. See escape codes for formatting options.}
\end{description}
\item [Notes:] {Currently no argument replacement is done with the variable arguments.}
\end{description}

\subsection{cgetc}
\index{cgetc}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] { Waits until a character is in the keyboard buffer and returns it }
\item [Syntax:] \stw{unsigned char cgetc (void);}
\item [Desription:] {The last character in the keyboard buffer }
\item [Notes:] {Returned values are ASCII character codes}
\end{description}

\subsection{kbhit}
\index{kbhit}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] { Returns the character in the keyboard buffer }
\item [Syntax:] \stw{unsigned char kbhit (void);}
\item [Desription:] {The character code in the keyboard buffer,  0 otherwise. }
\item [Notes:] {Returned values are ASCII character codes}
\end{description}

\subsection{getkeymodstate}
\index{getkeymodstate}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {
   Return the key modifiers state, where bits:

    Bit           Meaning             Constant
    ----------------------------------------------------
    0             Right SHIFT state   KEYMOD\_RSHIFT
    1             Left  SHIFT state   KEYMOD\_LSHIFT
    2             CTRL state          KEYMOD\_CTRL
    3             MEGA/C= state       KEYMOD\_MEGA
    4             ALT state           KEYMOD\_ALT
    5             NOSCRL state        KEYMOD\_NOSCRL
    6             CAPSLOCK state      KEYMOD\_CAPSLOCK
    7             Reserved            -
    }
\item [Syntax:] \stw{unsigned char getkeymodstate(void)}
\item [Desription:] {A byte with the key modifier state bits.}
\end{description}

\subsection{flushkeybuf}
\index{flushkeybuf}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Flush the keyboard buffer}
\item [Syntax:] \stw{void flushkeybuf(void)}
\end{description}

\subsection{cinput}
\index{cinput}
\begin{description}[leftmargin=2cm,style=nextline]
\item [Description:] {Get input from keyboard, printing incoming characters at current position.}
\item [Syntax:] \stw{unsigned char cinput(char* buffer, unsigned char buflen, unsigned char flags)}
\item [Parameters:]
\begin{description}\item[]
\item [{\em buffer}:] {Target character buffer preallocated by caller}
\item [{\em buflen}:] {Target buffer length in characters}
\item [{\em flags}:] {Flags for input:  (default is accept all printable characters)

            CINPUT\_ACCEPT\_NUMERIC
            CINPUT\_ACCEPT\_LETTER
            CINPUT\_ACCEPT\_SYM
            CINPUT\_ACCEPT\_ALL
            CINPUT\_ACCEPT\_ALPHA
  }
\end{description}
\item [Desription:] {Successfully read characters in buffer}
\end{description}

