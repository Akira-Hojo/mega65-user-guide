\newenvironment{hyppotrap}[3]
{
  \newcommand{\availablefrom}[1]{Available starting with Hypervisor ##1}
  \newcommand{\errordesc}[3]{\textbf{\$##1 ##2} ##3\par}
  \newcommand{\notimplemented}{\item[Remarks:]\textbf{NOT IMPLEMENTED}\par}
  \newcommand{\register}[2]{\textbf{##1} ##2\par}
  \newcommand{\TODO}{\textbf{\color{red}TODO}}
  \titleformat*{\subsection}{\normalfont\huge\bfseries\color{blue}}
  \subsection{hdos\_#1}
  \index{Hypervisor Services!\$#2 \$#3}
  \begin{description}[leftmargin=2.7cm,style=nextline]
  \item [Trap:] LDA \#\$#3 : STA \$#2 : CLV
}
{
  \end{description}
}

\chapter{MEGA65 Hypervisor Services}
\index{Hypervisor Services}

\section{Introduction}
The MEGA65's Hypervisor provides services you can use in your programs. This
chapter describes these services.

This chapter describes Hypervisor verson 1.2.

New Hypervisor services may become available and existing Hypervisor services
may change or be deprecated. A robust program will use the hdos\_getversion
service to check whether the program is compatible with the Hypervisor in the
MEGA65 system it's running on.

% Jimbo - Do we commit to semantic versioning? Do we have a deprecation policy?

\subsection{Using}
When you want to use a hypervisor service, you don't use JSR. This is because
the Hypervisor exists in a space that's seperate from regular code. In order to
access it, the CPU needs to switch into the Hypervisor.

At addresses \$D640 -- \$D67F are set of hypervisor traps. Writing to these
addresses are not like writing to other addresses. Instead of writing to memory
or I/O, the CPU switches into the Hypervisor and starts a hypervisor service.
How the CPU does this is described in \bookvref{cha:cpu}.

Which hypervisor services starts depends on what value from the A register you
write and which trap you write to. Each of the services described in this
chapter tells you what value to write and which trap to use. You have to use the
A register when triggering a trap. Writing the same value from another register
won't work.

When the hypervisor service finishes, the CPU will switch back to your program.
Except for the registers a service uses to return values, the registers are
otherwise preserved.

\textbf{Important} The CPU may or may not execute the next byte in your program
after the hypervisor service finishes. Put a CLV instruction after the STA.
It shouldn't change the behaviour of your program if the CPU does or not does
not actually execute the CLV instruction. If your program does rely on the V
flag, you can use the NOP instruction instead. When you use NOP you must be
mindful that the CPU might interpet the NOP as an prefix for the following
instruction. For this reason, you should prefer using CLV over NOP.

\subsection{Errors}

If the service was successful, it will set the C flag.

If the service was unsuccessful, it will clear the C flag and put an error code
in the A register. Each of the services described in this chapter lists which
error codes a services returns and why. There is also a table of error codes in
the description for hdos\_geterrorcode.

\subsection{Drives}

% Jimbo - These should be named as what they are, partitions.
%         This would resolve potential confusion when we do start referring
%         to the virtual F011's drive 0 and 1 around mounting disk images.

In the Hypervisor, drives are the partitions of the internal and external SD
cards. They are not the drive 0 and drive 1 of the F011 floppy controller. They
are also not the drive 0 and drive 1 of dual-drive disk units that attach to the
serial bus.



% ==============================================================================
% General Services
% ==============================================================================
\newpage
\section{General Services}

% ******************************************************************************
% geterrorcode
% ******************************************************************************
\begin{hyppotrap}{geterrorcode}{D640}{38}
\item [Service:]
  Returns the current error code from the Hypervisor.
\item [Precondition:]
  The previous service trapped cleared the C flag.
\item [Outputs:]
  \register{A}{The error code of the previously failed service.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  The error code is only valid if the previous service cleared the C flag.
  If the C flag was set there was no error and this error code is undefined.

  The meanings here are generic. See the subsections for the individual services
  for more specific meanings.
\item [Error codes:] This is possibly not an exhaustive list.
{
  \setlength{\def\arraystretch{1.5}\tabcolsep}{3pt}
  \begin{longtable}{|r|r|l|p{8cm}|}
    \hline
    \textbf{Hex} & \textbf{Dec} & \textbf{Name} & \textbf{Common meaning}\\
    \hline
    \endhead
    1 & 1 & \makecell[tl]{partition not \\ interesting} &
    An attempt to mount a partition was rejected because the partition was not
    of a supported type
    \\\hline
    2 & 2 & bad signature &
    The signature bytes at the end of a partition table or of the first sector
    of a partition were missing or incorrect
    \\\hline
    3 & 3 & is small FAT &
    An attempt was made to mount a FAT12 or FAT16 partition. Only FAT32
    partitions are supported
    \\\hline
    4 & 4 & \makecell[tl]{too many reserved\\clusters} &
    An attempt was made to mount a partition that has too many reserved sectors.
    The number of reserved sectors must be less than 65,536
    \\\hline
    5 & 5 & not two FATs &
    An attempt was made to mount a partition that does not have exactly two
    copies of the FAT structure
    \\\hline
    6 & 6 & too few clusters &
    An attempt was made to mount a partition that contains a partition with too
    few clusters
    \\\hline
    7 & 7 & read timeout &
    The read took long for the read rquest to be fulfilled
    \\\hline
    8 & 8 & partition error &
    An unspecified error occurred while handling a partition
    \\\hline
    10 & 16 & invalid address &
    An invalid address was supplied in an argument
    \\\hline
    11 & 17 & illegal value &
    An illegal value was supplied in an argument
    \\\hline
    20 & 32 & read error &
    An unspecified error occurred while reading
    \\\hline
    21 & 33 & write error &
    An unspecified error occurred while writing
    \\\hline
    80 & 128 & no such drive &
    An attempt was made to select or operate on a drive (SD card partition)
    that does not exist
    \\\hline
    81 & 129 & name too long &
    The supplied filename was too long
    \\\hline
    82 & 130 & not implemented &
    The hypervisor service is not implemented
    \\\hline
    83 & 131 & file too long &
    An attempt was made to load a file into memory that is longer than 16MB
    \\\hline
    84 & 132 & \makecell[tl]{too many\\open files} &
    Too many files are open, and no free file descriptor could be obtained
    \\\hline
    85 & 133 & invalid cluster &
    The supplied cluster number is invalid
    \\\hline
    86 & 134 & is a directory &
    An attempt was made to operate on a directory, where a normal file was
    expected
    \\\hline
    87 & 135 & not a directory &
    An attempt was made to operate on a normal file, where a directory was
    expected
    \\\hline
    88 & 136 & file not found &
    The requested file could not be located in the current directory of the
    current disk.
    \\\hline
    89 & 137 & \makecell[tl]{invalid file\\descriptor} &
    An invalid file descriptor was supplied
    \\\hline
    8A & 138 & \makecell[tl]{image wrong\\length} &
    A disk image file had the wrong length, and was rejected for this reason
    \\\hline
    8B & 139 & image fragmented &
    A disk image could not be mounted because it is not stored contiguously
    \\\hline
    8C & 140 & no space &
    The disk image or SD card has no free space for the requested operation
    \\\hline
    8D & 141 & file exists &
    An attempt was made to create a file that already exists, or to rename a
    file to have the name of a file that already exists
    \\\hline
    8E & 142 & directory full &
    An attempt was made to create a file in a directory that cannot accommodate
    any more entries
    \\\hline
    FF & 255 & eof &
    The end of a file or directory was encountered
    \\\hline
  \end{longtable}
}
\end{hyppotrap}


% ******************************************************************************
% getversion
% ******************************************************************************
\newpage
\begin{hyppotrap}{getversion}{D640}{00}
\item [Service:]
  Returns the version of the Hypervisor operating system and its HDOS.
\item [Outputs:]
  \register{A}{The major version number of the Hypervisor}
  \register{X}{The major version number of the Hypervisor}
  \register{Y}{The minor version number of HDOS}
  \register{Z}{The major version number of HDOS}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  The HDOS in the Hypervisor is not related to the CBDOS inside Kernal 65 or the
  DOS in the disk drives attached to the serial port.
\item [Example:]
  Tests if the Hypervisor version is $\geq$ 1.2 and $<$ 2.0.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Get the version numbers
    LDA #$00
    STA $D640
    CLV
    ;; Test if the major version number of the Hypervisor is 1
    CMP #1
    BNE @incompatible
    ;; Test if the minor version number of the Hypervisor is >= 2
    TXA
    CMP #2
    BMI @incompatible
    RTS
@incompatible:
    BRK
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% setup_transfer_area
%
% Jimbo - What are the post-conditions for this? What services are affected by
%         this?
%       - Is this now redudant? So far everything I've used has the transfer
%         area as a parameter.
% ******************************************************************************
\newpage
\begin{hyppotrap}{setup\_transfer\_area}{D640}{3A}
\item [Service:]
  Sets up the area the hypervisor will use to transfer data to and from your
  program.
\item [Inputs:]
  \register{Y}{The MSB of the transfer area's address}
\item [Errors:]
  \errordesc{10}{invalid address}{The transfer area address in Y is invalid.
  It must be $\leq$ \$7E}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  The transfer area must be between \$0000 and \$7E00. It must also begin on a
  page boundary. The LSB of its address must be \$00.

  The transfer area is 256 bytes long for most services.

  The transfer area is indicated using the processor's current memory mapping at
  the time that a service is called. However, it is good practice to always
  place it in the bottom 32KB of bank 0.
\item [Example:]
  Reserves 256 bytes on a page boundary and sets it up as the transfer area.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    LDY #>transferarea
    LDA #$3A
    STA $D640
    CLV
    BCC @error
    RTS
@error:
    BRK
    !align 255, 0
transferarea:
    !skip 256
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}



% ==============================================================================
% Disk/storage services
% ==============================================================================
\newpage
\section{Drive/Storage Services}


% ******************************************************************************
% chdir
% ******************************************************************************
\begin{hyppotrap}{chdir}{D640}{0C}
\item [Service:]
  Changes the current working directory.
\item [Preconditions:]
  The FAT dir entry for the directory you want to change to has been
  found. hdos\_findfile is typically used to find a FAT dir entry.
  hdos\_findfirst, hdos\_findnext and hdos\_readdir can also be used.
\item [Errors:]
  \errordesc{87}{not a directory}{The FAT dir entry last found isn't for a
  directory. Bit 4 of the FAT dir entry's attribute byte is set for
  directories.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  You can move up to the parent directory by finding the .. FAT dir entry.

  You cannot move up or down more than one directory at a time.

  Use hdos\_cdrootdir to direcly change back to the root directory.
\end{hyppotrap}


% ******************************************************************************
% getcurrentdrive
% ******************************************************************************
\newpage
\begin{hyppotrap}{getcurrentdrive}{D640}{04}
\item [Service:]
  Returns the number of the currently selected drive (SD card partition).
\item [Outputs:]
  \register{A}{The current drive number}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  hdos\_selectdrive changes the current drive number. hdos\_cdrootdir
  can also change it.
\item [Example:]
  Prints the number of the currently selected drive in the top-left of the
  screen. This example assumes that aren't more than 10 drives (drives 0 to 9).
  It also assumes the screen memory hasn't been moved from \$000800.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Get the current drive
    LDA #$04
    STA $D640
    CLV
    BCC @error
    ;; Convert the drive number in A into a screen code
    STA @temp
    LDA #$30
    ADC @temp
    LDA @temp
    ;; Put the screen code into the top-left of screen memmory
    STA $0800
    RTS
@error:
    BRK
@temp:
    !skip 1
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% getcwd
% ******************************************************************************
\newpage
\begin{hyppotrap}{getcwd}{D640}{0A}
\item [Service:]
  Return information on the currently selected directory or sub-directory.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% getdefaultdrive
% ******************************************************************************
\newpage
\begin{hyppotrap}{getdefaultdrive}{D640}{02}
\item [Service:]
  Returns the drive number (SD card partition) the Hypervisor selected while
  booting.
\item [Outputs:]
  \register{A}{The default drive number}
\item [History:]
  \availablefrom{1.2}
\item [Example:]
  Selects the default drive.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Get the default drive
    LDA #$02
    STA $D640
    CLV
    BCC @error
    ;; Transfer the drive number in A to X
    TAX
    ;; Select the default drive
    LDA #$06
    STA $D640
    CLV
    BCC @error
    RTS
@error:
    BRK
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% getdrivesize
% ******************************************************************************
\newpage
\begin{hyppotrap}{getdrivesize}{D640}{08}
\item [Service:]
  Returns information on the size of the currently selected drive (SD card
  partition).
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% mkdir
% ******************************************************************************
\newpage
\begin{hyppotrap}{mkdir}{D640}{0E}
\item [Service:]
  Creates a sub-directory.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% opendir
% ******************************************************************************
\newpage
\begin{hyppotrap}{opendir}{D640}{12}
\item [Service:]
  Opens the current working directory for reading the file entries in it.
\item [Preconditions:]
  The drive and directory you want to read have already been set up using
  hdos\_selectdrive and hdos\_chdir if necessary.
\item [Ouptuts:]
  \register{A}{A file descriptor for reading the directory. You are responsible
  for closing this file descriptor using hdos\_closedir.}
\item [Postconditions:]
  Using hdos\_readdir with this file descriptor returns reads the first FAT dir
  entry in the directory.
\item [Errors:]
  \errordesc{7}{read timeout}{Reading the initial directory information took too
  long}
  \errordesc{8}{partition error}{An unspecified error occurred while handling
  the currently selected partition}
  \errordesc{10}{invalid address}{An invalid address was supplied in an argument} % Jimbo - How does this error occur? Is this part of the interface?
  \errordesc{11}{illegal value}{An illegal value was supplied in an argument} % Jimbo - How does this error occur? Is this part of the interface?
  \errordesc{20}{read error}{An unspecified error occurred while reading}
  \errordesc{21}{write error}{An unspecified error occurred while writing} % Jimbo - How does this error occur? Is this part of the interface?
  \errordesc{80}{no such drive}{An attempt was made to select or operate on a
  drive (SD card partition) that does not exist} % Jimbo - How does this error occur? Is this part of the interface?
  \errordesc{84}{too many open files}{All the file descriptors are in use.
  hdos\_opendir and hdos\_openfile share the same very small pool of file
  descriptors. Close some or all of the file descriptors using hdos\_closedir,
  hdos\_closefile or hdos\_closeall.}
\item [Example:]
  Calls processdirentry for each FAT dir entry in the current working directory.
  processdirentry is assumed to be defined elsewhere.

  \TODO
\end{hyppotrap}


% ******************************************************************************
% rmdir
% ******************************************************************************
\newpage
\begin{hyppotrap}{rmdir}{D640}{10}
\item [Service:]
  Removes a sub-directory.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% selectdrive
% ******************************************************************************
\newpage
\begin{hyppotrap}{selectdrive}{D640}{06}
\item [Service:]
  Selects the currently selected drive (SD card partition).
\item [Preconditions:]
  The Hypervisor has assigned a drive number to the SD card partition.
\item [Inputs:]
  \register{X}{The drive number to become the new current drive}
\item [Postconditions:]
  getcurrentdrive returns the value that was in the X register.

  The Hypervisor services operate on the newly selected drive.
\item [Errors:]
  \errordesc{80}{no such drive}{The drive in the X register does not exist.
  The Hypervisor only assigns drive numbers to the SD card partitions it can
  read.}
\item [History:]
  \availablefrom{1.2}
\item [Example:]
  Tests if drive 2 exists by trying to select it. Returns with the C flag set if
  drive 2 exists.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Preserve the current drive in Z so we can restore it later
    LDA #$04
    STA $D640
    CLV
    BCC @error
    TAZ
    ;; Try to select drive 2
    LDX #2
    LDA #$06
    STA $D640
    CLV
    BCC @mightnotexist
    ;; Transfer the previously selected drive number in Z to X
    TZA
    TAX
    ;; Restore the previously selected drive
    LDA #$06
    STA $D640
    CLV
    BCC @error
    ;; The C flag was already set by the Hypervisor service
    RTS
\end{verbatim}
\end{tcolorbox}
\ldots{} continues on the next page \ldots
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
@mightnotexist:
    ;; If the error code in A is $80, the drive doesn't exist;
    ;; otherwise some other kind of error occured
    CMP #$80
    BNE @error
    ;; Clear the C flag because the drive doesn't exist
    CLC
    RTS
@error:
    BRK
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}



%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------



\chapter{MEGA65 Hypervisor Services (old)}

The MEGA65's Hypervisor provides a number of services via Hypervisor Traps.
This chapter will describe these services.  For detailed information on how
Hypervisor Traps are facilitated by the CPU is described in \bookvref{cha:cpu}.

The hypervisor calls are identified by the trap register (\$D640 -- \$D67F), and
the value of the accumulator register when writing to the trap register.  Thus
a hypervisor call \$00:\$02 would be made via the following sequence of instructions:

\begin{screenoutput}
  LDA #$02         
  STA $D640+$00
  NOP                ; All traps calls MUST be followed by a NOP instruction
\end{screenoutput}

The values of the other registers or other structures will be described for
each individual call.

\section{General Services}

\subsection{\$00:\$00 -- Get Hypervisor Version}

Returns the version of the Hypervisor operating system and DOS components in the
four registers:

\begin{itemize}
  \item A = Hypervisor Operating System Major Version number. 
  \item X = Hypervisor Operating System Minor Version number. 
  \item Y = Hypervisor DOS Minor Version number. 
  \item Z = Hypervisor DOS Major Version number. 
\end{itemize}

These values can be used to check whether a given MEGA65 system's hypervisor
supports features that become available (or are deprecated) at particular versions.

\subsection{\$00:\$38 -- Get Current Error Code (geterrorcode)}

Returns the current error code from the Hypervisor.  The currently supported
error codes are:

\begin{itemize}
\item \$01 (1) -- Partition Not Interesting, indicating that an attempt to mount a partition was rejected because the partition was not of a supported type.
\item \$02 (2) -- Bad Signature, indicating that the signature bytes at the end of a partition table or of the first sector of a partition were missing or incorrect.
\item \$03 (3) -- An attempt was made to mount a FAT12 or FAT16 partition.  Only FAT32 partitions are supported.
\item \$04 (4) -- An attempt was made to mount a partition that has too many reserved sectors. The number of reserved sectors must be less than 65,536.
  \item \$05 (5) -- An attempt was made to mount a partition that does not have exactly two copies of the FAT structure.
\item \$06 (6) -- An attempt was made to mount a partition that contains a partition with too few clusters.
\item \$07 (7) -- A read timeout occurred.
  \item \$08 (8) -- An unspecified error occurred while handling a partition.
\item \$10 (16) -- An invalid address was supplied to the Setup Transfer Area For Other Calls function.
\item \$11 (17) -- An illegal value was supplied to a Hypervisor call.
\item \$20 (32) -- A read error occurred.
\item \$21 (33) -- A write error occurred.
\item \$80 (128) -- An attempt was made to select or operate on a disk or partition that does not exist.
\item \$81 (129) -- The supplied filename was too long.
\item \$82 (130) -- A Hypervisor call was made to a function that is not implemented. 
\item \$83 (131) -- An attempt was made to load a file into memory that is longer than 16MB.
\item \$84 (132) -- Too many files are open, and no free file descriptor could be obtained for the requested operation.
\item \$85 (133) -- The supplied cluster number is invalid.
\item \$86 (134) -- An attempt was made to operate on a directory, where a normal file was expected.
\item \$87 (135) -- An attempt was made to operate on a normal file, where a directory was expected.
\item \$88 (136) -- The requested file could not be located.
\item \$89 (137) -- An invalid file descriptor was supplied.
\item \$8A (138) -- A disk image file had the wrong length, and was rejected for this reason.
\item \$8B (139) -- A disk image was attempted to be mounted, but could not because it is fragmented on the file system.  Disk images must be stored contiguously on disk. This is because of the way that the SD card controller and floppy controller work: They load the starting sector of the disk image into special registers, and have no way to correctly handle a disk image that is stored in separate pieces on the disk. 
\item \$8C (140) -- The disk has no free space for the requested operation.
\item \$8D (141) -- An attempt was made to create a file that already exists, or to rename a file to have the name of a file that already exists.
\item \$8E (142) -- An attempt was made to create a file in a directory that cannot accommodate any more entries.
\item \$FF (255) -- The end of a file or directory was encountered.
\end{itemize}

\subsection{\$00:\$3A -- Setup Transfer Area for Other Calls (setup\_transfer\_area)}

Setup the transfer area for various hypervisor calls. The page number of the transfer area is supplied in the Y register.
This page must be between \$00 (0) and \$7E (126), thus indicating a transfer area starting between \$0000 and \$7E00 (0 and 32,256).
The transfer area is
256 bytes long for most calls.  Note that the transfer area is indicated using the processor's current memory mapping at
the time that a function is called.  However, it is good practice to always place it in the bottom 32KB of main memory.

\begin{itemize}
  \item Y = Page number of the transfer area (\$00 -- \$7E).
\end{itemize}

This call can produce the following error codes:

\begin{itemize}
\item \$10 (16) -- An invalid transfer area address was supplied, i.e., Y > \$7E (126).
\end{itemize}

\section{Disk/Storage Hypervisor Calls}

\subsection{\$00:\$02 -- Get Default Drive (SD card Partition)}

This call returns the default drive (SD card partition) number in the A register.

\subsection{\$00:\$04 -- Get Current Drive (SD card Partition)}

This call returns the current selected drive (SD card partition) in the A register.

\subsection{\$00:\$06 -- Select Drive (SD card Partition)}

This call sets the currently selected drive (SD card partition) to the drive indicated in the X register.

\begin{itemize}
  \item X = Selected drive (SD card partition) number.
\end{itemize}

This call can produce the following error codes:

\begin{itemize}
\item \$80 (128) -- An attempt was made to select or operate on a disk or partition that does not exist.
\end{itemize}

\subsection{\$00:\$08 -- {\em NOT IMPLEMENTED} Get Disk Size}

When implemented, this call will return information on the size of the currently selected disk (SD card partition).

\subsection{\$00:\$0A -- {\em NOT IMPLEMENTED} Get Current Working Directory}

When implemented, this call will return information on the currently selected directory or sub-directory.

\subsection{\$00:\$0C -- Change Working Directory}

Changes the current working directory to the directory specified in the dirent structure. The dirent structure
can be populated by using any of the findfirst, findnext, findfile, or readdir Hypervisor calls.

This call can produce the following error codes:

\begin{itemize}
\item \$87 (135) -- An attempt was made to operate on a normal file, where a directory was expected.
\end{itemize}

\subsection{\$00:\$0E -- {\em NOT IMPLEMENTED} Create Directory}

When implemented, this call will allow the creation of new subdirectories.

\subsection{\$00:\$10 -- {\em NOT IMPLEMENTED} Remove Directory}

When implemented, ths call will allow the removal of a directory.

\subsection{\$00:\$12 -- Open Directory (opendir)}

Open the current working directory.

On success, it returns the file descriptor of the opened directory in the A register.

This call can result in the following error codes:

\begin{itemize}
\item \$07 (7) -- A read timeout occurred.
  \item \$08 (8) -- An unspecified error occurred while handling a partition.
\item \$10 (16) -- An invalid address was supplied to the Setup Transfer Area For Other Calls function.
\item \$11 (17) -- An illegal value was supplied to a Hypervisor call.
\item \$20 (32) -- A read error occurred.
\item \$21 (33) -- A write error occurred.
\item \$80 (128) -- An attempt was made to select or operate on a disk or partition that does not exist.
\item \$84 (132) -- Too many files are open, and no free file descriptor could be obtained for the requested operation.
\end{itemize}

\subsection{\$00:\$14 -- Read Next Directory Entry (readdir)}
\subsection{\$00:\$16 -- Close Directory (closedir)}
\subsection{\$00:\$18 -- Open File (openfile)}
\subsection{\$00:\$1A -- Read From a File (readfile)}
\subsection{\$00:\$1C -- {\em NOT IMPLEMENTED} Write to a File (writefile)}
\subsection{\$00:\$1E -- {\em NOT IMPLEMENTED} Create File (mkfile)}

\subsection{\$00:\$20 -- Close a File (closefile)}
\subsection{\$00:\$22 -- Close All Open Files (closeall)}
\subsection{\$00:\$24 -- {\em NOT IMPLEMENTED} Seek to a Given Offset in a File (seekfile)}
\subsection{\$00:\$26 -- {\em NOT IMPLEMENTED} Delete a File (rmfile)}
\subsection{\$00:\$28 -- {\em NOT IMPLEMENTED} Get Information About a File (fstat)}
\subsection{\$00:\$2A -- {\em NOT IMPLEMENTED} Rename a File (rename)}
\subsection{\$00:\$2C -- {\em NOT IMPLEMENTED} Set time stamp of a file (filedate)}
\subsection{\$00:\$2E -- Set the current filename (setname)}

Sets the current Hypervisor filename to the ASCIIZ string stored at \$YYXX. The provided address
must be in the first 31KB of main memory.  Addresses at \$7F00 or above will result in errors.

The filename indicates a file in the current working directory of the SD card's FAT file system.
This call will {\em not} work with names of files that are stored on floppy disks or floppy disk
images.  

\subsection{\$00:\$30 -- Find first matching file (findfirst)}
\subsection{\$00:\$32 -- Find subsequent matching file (findnext)}
\subsection{\$00:\$34 -- Find matching file (one only) (findfile)}
\subsection{\$00:\$36 -- Load a File into Main Memory (loadfile)}

On success, this call loads the file specified by the setname Hypervisor call into the specified
address in main (chip) memory.  It is limited to files of 16MB size, and the first 16MB of
the address space.  The load address will be \$00ZZYYXX.

Addresses during loading will wrap around within the same 16MB region of memory, i.e., the most
significant address byte will not be incremented during loading.

\subsection{\$00:\$3C -- Change Working Directory to Root Directory of Selected Partition}
\subsection{\$00:\$3E -- Load a File into Attic Memory (loadfile\_attic)}

On success, this call loads the file specified by the setname Hypervisor call into the specified
address in the Attic RAM memory.  It is limited to files of 16MB size, and the first 16MB of
the attic RAM address space.  The load address will be \$08ZZYYXX.

Addresses during loading will wrap around within the same 16MB region of memory, i.e., the most
significant address byte will not be incremented during loading.

\section{Disk Image Management}

\subsection{\$00:\$40 -- Attach a D81 Disk Image to Drive 0}
\subsection{\$00:\$42 -- Detach All D81 Disk Images}
\subsection{\$00:\$44 -- Write Enable All Currently Attached D81 Disk Images}
\subsection{\$00:\$46 -- Attach a D81 Disk Image to Drive 1}

\section{Task and Process Management}

\subsection{\$00:\$50 -- {\em NOT IMPLEMENTED} Get Task List}
\subsection{\$00:\$52 -- {\em NOT IMPLEMENTED} Send Message to Another Task}
\subsection{\$00:\$54 -- {\em NOT IMPLEMENTED} Receive Messages From Other Tasks}
\subsection{\$00:\$56 -- {\em NOT IMPLEMENTED} Write Into Memory of Another Task}
\subsection{\$00:\$58 -- {\em NOT IMPLEMENTED} Read From Memory of Another Task}

\subsection{\$00:\$60 -- {\em NOT IMPLEMENTED} Terminate Another Task}
\subsection{\$00:\$62 -- {\em NOT IMPLEMENTED} Create a Native MEGA65 Task}
\subsection{\$00:\$64 -- {\em NOT IMPLEMENTED} Load File Into Task}
\subsection{\$00:\$66 -- {\em NOT IMPLEMENTED} Create a C64-Mode Task}
\subsection{\$00:\$68 -- {\em NOT IMPLEMENTED} Create a C65-Mode Task}
\subsection{\$00:\$6A -- {\em NOT IMPLEMENTED} Exit and Switch to Another Task}
\subsection{\$00:\$6C -- {\em NOT IMPLEMENTED} Context-Switch to Another Task}
\subsection{\$00:\$6E -- {\em NOT IMPLEMENTED} Exit This Task}

\subsection{\$00:\$70 -- Toggle Write Protection of ROM Area}
\subsection{\$00:\$72 -- Toggle 4510 vs 6502 Processor Mode}
\subsection{\$00:\$74 -- Get current 4510 memory MAPping}

Y = page where memory mapping is to be stored.  Six bytes will be returned:
Y must be <= \$7E.

\begin{itemize}
  \item \$00 - Low byte of MAPLO (lower 32KB RAM mapping)
  \item \$01 - High byte of MAPLO (lower 32KB RAM mapping)
  \item \$02 - Low byte of MAPHI (upper 32KB RAM mapping)
  \item \$03 - High byte of MAPHI (upper 32KB RAM mapping)
  \item \$04 - Megabyte offset for MAPLO (lower 32KB RAM mapping)
  \item \$05 - Megabyte offset for MAPHI (upper 32KB RAM mapping)
\end{itemize}

\subsection{\$00:\$76 -- Set 4510 memory MAPping}

This call performs the opposite of the Get 4510 memory MAPping, reading 6 bytes
from the memory page indicated by Y, and storing them into the current processor's mapping status.
Y must be <= \$7E.

\subsection{\$00:\$7C -- Write Character to Serial Monitor/Matrix Mode Interface}
\subsection{\$00:\$7E -- Reset MEGA65}

\subsection{\$01:\$00 -- Enable Write Protection of ROM Area}
\subsection{\$01:\$02 -- Disable Write Protection of ROM Area}

\section{System Partition \& Freezing}

\subsection{\$02:\$00 -- Read System Config Sector Into Memory}
\subsection{\$02:\$02 -- Write System Config Sector From Memory}
\subsection{\$02:\$04 -- Apply System Config Sector Current Loaded Into Memory}
\subsection{\$02:\$06 -- Set DMAgic Revision Based On Loaded ROM}

\subsection{\$02:\$10 -- Locate First Sector of Freeze Slot}
\subsection{\$02:\$12 -- Unfreeze From Freeze Slot}
\subsection{\$02:\$14 -- Read Freeze Region List}
\subsection{\$02:\$16 -- Get Number of Freeze Slots}

\subsection{\$03:\$XX -- Write Character to Serial Monitor/Matrix Mode Interface}

\section{Secure Mode}

\subsection{\$11:\$XX -- Request Enter Secure Mode}
\subsection{\$12:\$XX -- Request Exit Secure Mode}
\subsection{\$32:\$XX -- {\em DEPRECATED} Set Protected Hardware Configuration}

This call will be removed once the secure mode framework is more completely implemented.

Until it is removed, this call allows a process to request the setting of the protected hardware configuration to allow or restrict access to various sub-systems, including the SD card storage system.

\subsection{\$3F:\$XX -- Freeze Self}

