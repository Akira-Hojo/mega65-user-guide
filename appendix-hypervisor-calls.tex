\newenvironment{hyppotrap}[3]
{
  \newcommand{\availablefrom}[1]{Available starting with Hypervisor ##1}
  \newcommand{\errordesc}[3]{\textbf{\$##1 ##2} ##3\par}
  \newcommand{\notimplemented}{\item[Remarks:]\textbf{NOT IMPLEMENTED}\par}
  \newcommand{\register}[2]{\textbf{##1} ##2\par}
  \newcommand{\TODO}{\textbf{\color{red}TODO}}
  \titleformat*{\subsection}{\normalfont\huge\bfseries\color{blue}}
  \subsection{hdos\_#1}
  \index{Hypervisor Services!\$#2 \$#3}
  \index{Registers!\$#2}
  \begin{description}[leftmargin=2.7cm,style=nextline]
  \item [Trap:] LDA \#\$#3 : STA \$#2 : CLV
}
{
  \end{description}
}

\chapter{MEGA65 Hypervisor Services}
\index{Hypervisor Services}
\index{Registers!\$D640}
\index{Registers!\$D641}
\index{Registers!\$D642}
\index{Registers!\$D643}
\index{Registers!\$D644}
\index{Registers!\$D645}
\index{Registers!\$D646}
\index{Registers!\$D647}
\index{Registers!\$D648}
\index{Registers!\$D649}
\index{Registers!\$D64A}
\index{Registers!\$D64B}
\index{Registers!\$D64C}
\index{Registers!\$D64D}
\index{Registers!\$D64E}
\index{Registers!\$D64F}
\index{Registers!\$D650}
\index{Registers!\$D651}
\index{Registers!\$D652}
\index{Registers!\$D653}
\index{Registers!\$D654}
\index{Registers!\$D655}
\index{Registers!\$D656}
\index{Registers!\$D657}
\index{Registers!\$D658}
\index{Registers!\$D659}
\index{Registers!\$D65A}
\index{Registers!\$D65B}
\index{Registers!\$D65C}
\index{Registers!\$D65D}
\index{Registers!\$D65E}
\index{Registers!\$D65F}
\index{Registers!\$D660}
\index{Registers!\$D661}
\index{Registers!\$D662}
\index{Registers!\$D663}
\index{Registers!\$D664}
\index{Registers!\$D665}
\index{Registers!\$D666}
\index{Registers!\$D667}
\index{Registers!\$D668}
\index{Registers!\$D669}
\index{Registers!\$D66A}
\index{Registers!\$D66B}
\index{Registers!\$D66C}
\index{Registers!\$D66D}
\index{Registers!\$D66E}
\index{Registers!\$D66F}
\index{Registers!\$D670}
\index{Registers!\$D671}
\index{Registers!\$D672}
\index{Registers!\$D673}
\index{Registers!\$D674}
\index{Registers!\$D675}
\index{Registers!\$D676}
\index{Registers!\$D677}
\index{Registers!\$D678}
\index{Registers!\$D679}
\index{Registers!\$D67A}
\index{Registers!\$D67B}
\index{Registers!\$D67C}
\index{Registers!\$D67D}
\index{Registers!\$D67E}
\index{Registers!\$D67F}

\section{Introduction}
The MEGA65's Hypervisor provides services you can use in your programs. This
chapter describes these services.

This chapter describes Hypervisor verson 1.2.

New Hypervisor services may become available and existing Hypervisor services
may change or be deprecated. A robust program will use the hdos\_getversion
service to check whether the program is compatible with the Hypervisor in the
MEGA65 system it's running on.

% Jimbo - Do we commit to semantic versioning? Do we have a deprecation policy?

\subsection{Using}
When you want to use a hypervisor service, you don't use JSR. This is because
the Hypervisor exists in a space that's seperate from regular code. In order to
access it, the CPU needs to switch into the Hypervisor.

At addresses \$D640 -- \$D67F are set of hypervisor traps. Writing to these
addresses are not like writing to other addresses. Instead of writing to memory
or I/O, the CPU switches into the Hypervisor and starts a hypervisor service.
How the CPU does this is described in \bookvref{cha:cpu}.

Which hypervisor services starts depends on what value from the A register you
write and which trap you write to. Each of the services described in this
chapter tells you what value to write and which trap to use. You have to use the
A register when triggering a trap. Writing the same value from another register
won't work.

When the hypervisor service finishes, the CPU will switch back to your program.
Except for the registers a service uses to return values, the registers are
otherwise preserved.

\textbf{Important} The CPU may or may not execute the next byte in your program
after the hypervisor service finishes. Put a CLV instruction after the STA.
It shouldn't change the behaviour of your program if the CPU does or not does
not actually execute the CLV instruction. If your program does rely on the V
flag, you can use the NOP instruction instead. When you use NOP you must be
mindful that the CPU might interpet the NOP as an prefix for the following
instruction. For this reason, you should prefer using CLV over NOP.

\subsection{Errors}

If the service was successful, it will set the C flag.

If the service was unsuccessful, it will clear the C flag and put an error code
in the A register. Each of the services described in this chapter lists which
error codes a services returns and why. There is also a table of error codes in
the description for hdos\_geterrorcode.



% ==============================================================================
% General Services
% ==============================================================================
\newpage
\section{General Services}


% ******************************************************************************
% geterrorcode
% ******************************************************************************
\begin{hyppotrap}{geterrorcode}{D640}{38}
\item [Service:]
  Returns the current error code from the Hypervisor.
\item [Precondition:]
  The previous service trapped cleared the C flag.
\item [Outputs:]
  \register{A}{The error code of the previously failed service.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  The error code is only valid if the previous service cleared the C flag.
  If the C flag was set there was no error and this error code is undefined.

  The meanings here are generic. See the subsections for the individual services
  for more specific meanings.
\item [Error codes:] This is possibly not an exhaustive list.
{
  \setlength{\def\arraystretch{1.5}\tabcolsep}{3pt}
  \begin{longtable}{|r|r|l|p{8cm}|}
    \hline
    \textbf{Hex} & \textbf{Dec} & \textbf{Name} & \textbf{Common meaning}\\
    \hline
    \endhead
    1 & 1 & \makecell[tl]{partition not \\ interesting} &
    An attempt to mount a partition was rejected because the partition was not
    of a supported type
    \\\hline
    2 & 2 & bad signature &
    The signature bytes at the end of a partition table or of the first sector
    of a partition were missing or incorrect
    \\\hline
    3 & 3 & is small FAT &
    An attempt was made to mount a FAT12 or FAT16 partition. Only FAT32
    partitions are supported
    \\\hline
    4 & 4 & \makecell[tl]{too many reserved\\clusters} &
    An attempt was made to mount a partition that has too many reserved sectors.
    The number of reserved sectors must be less than 65,536
    \\\hline
    5 & 5 & not two FATs &
    An attempt was made to mount a partition that does not have exactly two
    copies of the FAT structure
    \\\hline
    6 & 6 & too few clusters &
    An attempt was made to mount a partition that contains a partition with too
    few clusters
    \\\hline
    7 & 7 & read timeout &
    The read took long for the read rquest to be fulfilled
    \\\hline
    8 & 8 & partition error &
    An unspecified error occurred while handling a partition
    \\\hline
    10 & 16 & invalid address &
    An invalid address was supplied in an argument
    \\\hline
    11 & 17 & illegal value &
    An illegal value was supplied in an argument
    \\\hline
    20 & 32 & read error &
    An unspecified error occurred while reading
    \\\hline
    21 & 33 & write error &
    An unspecified error occurred while writing
    \\\hline
    80 & 128 & no such drive &
    An attempt was made to select or operate on a drive (SD card partition)
    that does not exist
    \\\hline
    81 & 129 & {name too long} &
    The supplied filename was too long
    \\\hline
    82 & 130 & not implemented &
    The hypervisor service is not implemented
    \\\hline
    83 & 131 & file too long &
    An attempt was made to load a file into memory that is longer than 16MB
    \\\hline
    84 & 132 & \makecell[tl]{too many\\open files} &
    Too many files are open, and no free file descriptor could be obtained
    \\\hline
    85 & 133 & invalid cluster &
    The supplied cluster number is invalid
    \\\hline
    86 & 134 & is a directory &
    An attempt was made to operate on a directory, where a normal file was
    expected
    \\\hline
    87 & 135 & not a directory &
    An attempt was made to operate on a normal file, where a directory was
    expected
    \\\hline
    88 & 136 & file not found &
    The requested file could not be located in the current directory of the
    current drive.
    \\\hline
    89 & 137 & \makecell[tl]{invalid file\\descriptor} &
    An invalid file descriptor was supplied
    \\\hline
    8A & 138 & \makecell[tl]{image wrong\\length} &
    A disk image file had the wrong length, and was rejected for this reason
    \\\hline
    8B & 139 & image fragmented &
    A disk image could not be mounted because it is not stored contiguously
    \\\hline
    8C & 140 & no space &
    The disk image or SD card has no free space for the requested operation
    \\\hline
    8D & 141 & file exists &
    An attempt was made to create a file that already exists, or to rename a
    file to have the name of a file that already exists
    \\\hline
    8E & 142 & directory full &
    An attempt was made to create a file in a directory that cannot accommodate
    any more entries
    \\\hline
    FF & 255 & eof &
    The end of a file or directory was encountered
    \\\hline
  \end{longtable}
}
\end{hyppotrap}


% ******************************************************************************
% getversion
% ******************************************************************************
\newpage
\begin{hyppotrap}{getversion}{D640}{00}
\item [Service:]
  Returns the version of the Hypervisor operating system and its HDOS.
\item [Outputs:]
  \register{A}{The major version number of the Hypervisor}
  \register{X}{The major version number of the Hypervisor}
  \register{Y}{The minor version number of HDOS}
  \register{Z}{The major version number of HDOS}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  The HDOS in the Hypervisor is not related to the CBDOS inside Kernal 65 or the
  DOS in the disk drives attached to the serial port.
\item [Example:]
  Tests if the Hypervisor version is $\geq$ 1.2 and $<$ 2.0.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Get the version numbers
    LDA #$00
    STA $D640
    CLV
    ;; Test if the major version number of the Hypervisor is 1
    CMP #1
    BNE @incompatible
    ;; Test if the minor version number of the Hypervisor is >= 2
    TXA
    CMP #2
    BMI @incompatible
    RTS
@incompatible:
    BRK
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% setup_transfer_area
%
% Jimbo - What are the post-conditions for this? What services are affected by
%         this?
%       - Is this now redudant? So far everything I've used has the transfer
%         area as a parameter.
% ******************************************************************************
\newpage
\begin{hyppotrap}{setup\_transfer\_area}{D640}{3A}
\item [Service:]
  Sets up the area the Hypervisor will use to transfer data to and from your
  program.
\item [Inputs:]
  \register{Y}{The MSB of the transfer area's address}
\item [Errors:]
  \errordesc{10}{invalid address}{The transfer area address in Y $>$ \$7E}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  The transfer area must be between \$0000 and \$7E00. It must also begin on a
  page boundary. The LSB of its address must be \$00.

  The transfer area is 256 bytes long for most services.

  The transfer area is indicated using the processor's current memory mapping at
  the time that a service is called. However, it is good practice to always
  place it in the bottom 32KB of bank 0.
\item [Example:]
  Reserves 256 bytes on a page boundary and sets it up as the transfer area.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    LDY #>transferarea
    LDA #$3A
    STA $D640
    CLV
    BCC @error
    RTS
@error:
    BRK
    !align 255, 0
transferarea:
    !skip 256
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}



% ==============================================================================
% Disk/storage services
% ==============================================================================
\newpage
\section{Drive/Storage Services}

% Jimbo - These should be named as what they are, partitions.
%         This would resolve potential confusion when we do start referring
%         to the virtual F011's drive 0 and 1 around mounting disk images.

In the Hypervisor, drives are the partitions of the internal and external SD
cards. They are not the drive 0 and drive 1 of the F011 floppy controller. They
are also not the drive 0 and drive 1 of dual-drive disk units that attach to the
serial bus.


% ******************************************************************************
% chdir
% ******************************************************************************
\begin{hyppotrap}{chdir}{D640}{0C}
\item [Service:]
  Changes the current working directory.
\item [Preconditions:]
  The FAT dir entry for the directory you want to change to has been
  found. hdos\_findfile is typically used to find a FAT dir entry.
  hdos\_findfirst, hdos\_findnext and hdos\_readdir can also be used.
\item [Errors:]
  \errordesc{87}{not a directory}{The FAT dir entry last found isn't for a
  directory. Bit 4 of the FAT dir entry's attribute byte is set for
  directories.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  You can move up to the parent directory by finding the .. FAT dir entry.

  You cannot move up or down more than one directory at a time.

  Use hdos\_cdrootdir to direcly change back to the root directory.
\end{hyppotrap}


% ******************************************************************************
% closeall
% ******************************************************************************
\newpage
\begin{hyppotrap}{closeall}{D640}{22}
\item [Service:]
  Closes all the file descriptors.
\item [Postconditions:]
  Using any file descriptor with hdos\_closedir or hdos\_closefile succeeds.

  Using any file descriptor with hdos\_readdir or hdos\_readfile fails.

  hdos\_opendir and hdos\_openfile reuse the file descriptor.
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  You can also close individual file descriptors using hdos\_closedir or
  hdos\_closefile.
\end{hyppotrap}


% ******************************************************************************
% closedir
% ******************************************************************************
\newpage
\begin{hyppotrap}{closedir}{D640}{16}
\item [Service:]
  Closes a file descriptor for a directory.
\item [Preconditions:]
  The file descriptor given in the X register was opened using hdos\_opendir.
\item [Inputs:]
  \register{A}{A file descriptor for the directory}
\item [Postconditions:]
  Using the file descriptor again with hdos\_closedir succeeds.

  Using the file descriptor again with hdos\_readdir fails.

  hdos\_opendir and hdos\_openfile reuse the file descriptor.
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  You can also close all the open file descriptors using hdos\_closeall.
\item [Example:]
  See the examples in hdos\_opendir and hdos\_readdir.
\end{hyppotrap}


% ******************************************************************************
% closefile
% ******************************************************************************
\newpage
\begin{hyppotrap}{closefile}{D640}{20}
\item [Service:]
  Closes a file descriptor for a file.
\item [Preconditions:]
  The file descriptor given in the X register was opened using hdos\_openfile.
\item [Inputs:]
  \register{A}{A file descriptor for the file}
\item [Postconditions:]
  Using the file descriptor again with hdos\_closefile succeeds.

  Using the file descriptor again with hdos\_readfile fails.

  hdos\_opendir and hdos\_openfile reuse the file descriptor.
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  You can also close all the open file descriptors using hdos\_closeall.
\item [Example:]
  See the example in hdos\_openfile.
\end{hyppotrap}


% ******************************************************************************
% filedate
% ******************************************************************************
\newpage
\begin{hyppotrap}{filedate}{D640}{2C}
\item [Service:]
  Sets time stamp of a file.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% findfile
%
% Jimbo - Does this service work for files that don't have an LFN?
% ******************************************************************************
\newpage
\begin{hyppotrap}{findfile}{D640}{34}
\item [Service:]
  Finds the first file whose filename matches the current Hypervisor filename.
\item [Preconditions:]
  The current Hypervisor filename has been set using hdos\_setname.
\item [Postconditions:]
  No additional file descriptors are open.
\item [Errors:]
  \errordesc{88}{file not found}{A matching file was not found in the current
  directory of the current drive.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  % Jimbo - Why does the Hypervisor do this and create this restriction?
  The Hypervisor will only find files whose long filename is all in uppercase.
  The Hypervisor converts the current filename to ASCII uppercase before trying
  to match it. Bytes \$61 -- \$7B change to \$41 -- \$5A.

  The Hypervisor does not yet support the wildcard characters * and ?. Support
  for that is planned in a future version.

  This only finds the first matching file. You can find multiple matches by
  using hdos\_findfirst and hdos\_findnext.
\end{hyppotrap}


% ******************************************************************************
% findfirst
%
% Jimbo - Does this service work for files that don't have an LFN?
% ******************************************************************************
\newpage
\begin{hyppotrap}{findfirst}{D640}{30}
\item [Service:]
  Finds the first file whose filename matches the current Hypervisor filename.
\item [Preconditions:]
  The current Hypervisor filename has been set using hdos\_setname.
\item [Outputs:]
  \register{A}{A file descriptor for reading the current working directory. You
  might be responsible for closing this file descriptor using hdos\_closedir.
  See the remarks.}
\item [Postconditions:]
  hdos\_firstnext find the next matching file or fails with a file not found
  error.
\item [Side effects:]
  Sets the current file descriptor.
\item [Errors:]
  \errordesc{88}{file not found}{A matching file was not found in the current
  directory of the current drive.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  If the Hypervisor finds an initial matching file, it will set the C flag and
  return a file descriptor in the A register. This is a file descriptor for
  reading the current working directory. You are reponsible for closing it using
  hdos\_closedir. It's a standard directory file descriptor. You can use
  hdos\_readdir to read the FAT dir entries after the file that was found.

  If the Hypervisor doesn't find any mathcing files, it will fail with a file
  not found error. In this case they Hypervisor will have already closed the
  file descriptor and you don't close it.

  % Jimbo - Why does the Hypervisor do this and create this restriction?
  The Hypervisor will only find files whose long filename is all in uppercase.
  The Hypervisor converts the current filename to ASCII uppercase before trying
  to match it. Bytes \$61 -- \$7B change to \$41 -- \$5A.

  The Hypervisor does not yet support the wildcard characters * and ?. Support
  for that is planned in a future version.

  If you are only interested in the first match, you can use hdos\_findfile
  instead. hdos\_findfile always closes the file descriptor for you. But you
  can't use it to find multiple matching files.
\end{hyppotrap}


% ******************************************************************************
% findnext
%
% Jimbo - Does this service work for files that don't have an LFN?
% ******************************************************************************
\newpage
\begin{hyppotrap}{findnext}{D640}{32}
\item [Service:]
  Finds a subsequent file whose filename matches the current Hypervisor
  filename.
\item [Preconditions:]
  The current Hypervisor filename has been set using hdos\_setname.

  The first matching file has already been found successfully using
  hdos\_findfirst.
\item [Postconditions:]
  Using hdos\_firstnext again finds the next matching file or fails with a file
  not found error.
\item [Errors:]
  \errordesc{88}{file not found}{A subsequnt matching file was not found in the
  current directory of the current drive.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  If the Hypervisor doesn't find a subsequent mathcing file, it will fail with a
  file not found error. The Hypervisor will also close the file descriptor it
  output in hdos\_findfirst.

  If you don't exhaust the search by using hdos\_findnext until it fails with a
  file not found error, you are required to close the file descriptor yourself
  using hdos\_closedir.
\end{hyppotrap}


% ******************************************************************************
% fstat
% ******************************************************************************
\newpage
\begin{hyppotrap}{fstat}{D640}{28}
\item [Service:]
  Returns information about a file.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% getcurrentdrive
% ******************************************************************************
\newpage
\begin{hyppotrap}{getcurrentdrive}{D640}{04}
\item [Service:]
  Returns the number of the currently selected drive (SD card partition).
\item [Outputs:]
  \register{A}{The current drive number}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  hdos\_selectdrive changes the current drive number. hdos\_cdrootdir
  can also change it.
\item [Example:]
  Prints the number of the currently selected drive in the top-left of the
  screen. This example assumes that aren't more than 10 drives (drives 0 to 9).
  It also assumes the screen memory hasn't been moved from \$000800.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Get the current drive
    LDA #$04
    STA $D640
    CLV
    BCC @error
    ;; Convert the drive number in A into a screen code
    STA @temp
    LDA #$30
    ADC @temp
    LDA @temp
    ;; Put the screen code into the top-left of screen memmory
    STA $0800
    RTS
@error:
    BRK
@temp:
    !skip 1
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% getcwd
% ******************************************************************************
\newpage
\begin{hyppotrap}{getcwd}{D640}{0A}
\item [Service:]
  Return information on the currently selected directory or sub-directory.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% getdefaultdrive
% ******************************************************************************
\newpage
\begin{hyppotrap}{getdefaultdrive}{D640}{02}
\item [Service:]
  Returns the drive number (SD card partition) the Hypervisor selected while
  booting.
\item [Outputs:]
  \register{A}{The default drive number}
\item [History:]
  \availablefrom{1.2}
\item [Example:]
  Selects the default drive.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Get the default drive
    LDA #$02
    STA $D640
    CLV
    BCC @error
    ;; Transfer the drive number in A to X
    TAX
    ;; Select the default drive
    LDA #$06
    STA $D640
    CLV
    BCC @error
    RTS
@error:
    BRK
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% getdrivesize
% ******************************************************************************
\newpage
\begin{hyppotrap}{getdrivesize}{D640}{08}
\item [Service:]
  Returns information on the size of the currently selected drive (SD card
  partition).
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% loadfile
% ******************************************************************************
\newpage
\begin{hyppotrap}{loadfile}{D640}{36}
\item [Service:]
  Loads a file into chip memory.
\item [Preconditions:]
  The name of the file to load has been set using using hdos\_setname.
\item [Inputs:]
  \register{X}{The LSB of the address to start loading from}
  \register{Y}{The middle byte of the address to start loading from}
  \register{Z}{The MSB of the address to start loading from}
\item [Postconditions:]
  No additional file descriptors are open.
\item [Errors:]
  \errordesc{88}{file not found}{The file was not found in the current directory
  of the current drive.}
\item [Remarks:]
  This service can load files up to 16MB in size into the first 16MB of chip
  memory. Chip memory is the 384KB or more of memory inside the CPU module.

  Loading will start at 28-bit address \$00ZZYYXX. If loading tries to go beyond
  \$00FFFFFF, the loading will wrap around and continue at \$00000000.

  You can use hdos\_loadfile\_attic to load a file into hyper memory. The hyper
  memory is the 8MB or more of memory in the external RAM chips.
\end{hyppotrap}


% ******************************************************************************
% loadfile_attic
% ******************************************************************************
\newpage
\begin{hyppotrap}{loadfile\_attic}{D640}{3E}
\item [Service:]
  Loads a file into hyper memory.
\item [Preconditions:]
  The name of the file to load has been set using using hdos\_setname.
\item [Inputs:]
  \register{X}{The LSB of the address to start loading from}
  \register{Y}{The middle byte of the address to start loading from}
  \register{Z}{The MSB of the address to start loading from}
\item [Postconditions:]
  No additional file descriptors are open.
\item [Errors:]
  \errordesc{88}{file not found}{The file was not found in the current directory
  of the current drive.}
\item [Remarks:]
  This service can load files up to 16MB in size into the first 16MB of hyper
  memory. Hyper memory is the 8MB or more of memory in the external RAM chips.

  Loading will start at 28-bit address \$08ZZYYXX. If loading tries to go beyond
  \$08FFFFFF, the loading will wrap around and continue at \$08000000.

  You can use hdos\_loadfile to load a file into chip memory. The chip memory is
  the 384KB or more of memory inside the CPU module.
\end{hyppotrap}


% ******************************************************************************
% mkdir
% ******************************************************************************
\newpage
\begin{hyppotrap}{mkdir}{D640}{0E}
\item [Service:]
  Creates a sub-directory.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% mkfile
% ******************************************************************************
\begin{hyppotrap}{mkfile}{D640}{1E}
\item [Service:]
  Creates a file.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% opendir
% ******************************************************************************
\newpage
\begin{hyppotrap}{opendir}{D640}{12}
\item [Service:]
  Opens the current working directory for reading the file entries in it.
\item [Preconditions:]
  The drive and directory you want to read have already been set up using
  hdos\_selectdrive and hdos\_chdir if necessary.
\item [Ouptuts:]
  \register{A}{A file descriptor for reading the directory. You are responsible
  for closing this file descriptor using hdos\_closedir.}
\item [Postconditions:]
  hdos\_readdir reads the first FAT dir entry in the directory.
\item [Errors:]
  \errordesc{84}{too many open files}{All the file descriptors are in use.
  hdos\_opendir and hdos\_openfile share the same very small pool of file
  descriptors. Close some or all of the file descriptors using hdos\_closedir,
  hdos\_closefile or hdos\_closeall.}
  \errordesc{87}{not a directory}{The FAT dir entry last found is for a file.
  Use hdos\_openfile for files.}
\item [Example:]
  Calls processdirentry for each FAT dir entry in the current working directory.
  processdirentry is assumed to be defined elsewhere.

  \TODO
\end{hyppotrap}


% ******************************************************************************
% openfile
% ******************************************************************************
\newpage
\begin{hyppotrap}{openfile}{D640}{18}
\item [Service:]
  Opens a file on a drive.
\item [Preconditions:]
  The file has already been found. Files can be found using hdos\_findfile,
  hdos\_findfirst and hdos\_findnext. hdos\_readdir can alse be used to find a
  file.
\item [Ouptuts:]
  \register{A}{A file descriptor for accessing the file. You are responsible
  for closing this file descriptor using hdos\_closefile.}
\item [Postconditions:]
  Using hdos\_readfile with this file descriptor reads the first sector of the
  file.
\item [Side effects:]
  Sets the current file to the newly opened file. hdos\_readfile reads from the
  current file.
\item [Errors:]
  \errordesc{84}{too many open files}{All the file descriptors are in use.
  hdos\_opendir and hdos\_openfile share the same very small pool of file
  descriptors. Close some or all of the file descriptors using hdos\_closedir,
  hdos\_closefile or hdos\_closeall.}
  \errordesc{86}{is a directory}{The FAT dir entry last found is for a
  directory. Use hdos\_opendir for directories.}
\item [Remarks:]
  You cannot use this to open a file inside a disk image. To do that you use
  hdos\_d81attach0 or hdos\_d81attach1 to attach the disk image and then use
  either use the Kernal to read the file or program the virtualised F011 floppy
  controller.
\item [Example:]
  Finds, opens and then closes the file CONFIG.DAT.

\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Set the filename to CONFIG.DAT
    LDY #>filename
    LDA #$2E
    STA $D640
    CLV
    BCC @error
\end{verbatim}
\end{tcolorbox}

\ldots{} continues on the next page \ldots

\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Find the file
    LDA #$34
    STA $D640
    CLV
    BCC @error
    ;; Open the file
    LDA #$18
    STA $D640
    CLV
    BCC @error
    ;; Transfer the file descriptor in A to X
    TAX
    ;; Close the file
    LDA #$20
    STA $D640
    CLV
    BCC @error
    RTS
@error:
    BRK
    ;; The filename must start on a 256 byte page boundary.
    !align 255, 0
filename:
    !text "CONFIG.DAT", 0
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% readdir
% ******************************************************************************
\newpage
\begin{hyppotrap}{readdir}{D640}{14}
\item [Service:]
  Reads the next FAT dir entry.
\item [Preconditions:]
  The file descriptor given in the X register was opened using hdos\_opendir
  and hdos\_closedir hasn't since been used to close it.
\item [Inputs:]
  \register{X}{A file descriptor for the directory.}
  \register{Y}{The MSB of the address the Hypervisor will copy the FAT dir entry
  into. It must be $\leq$ \$7E. This destination address must be on a page
  boundary. It's LSB must be \$00. The destination area must be at least 87
  bytes.}
\item [Outputs:]
  Starting at \$YY00, the FAT dir entry has this structure.
  {\setlength{\tabcolsep}{2mm}
  \begin{tabular}{|c|c|p{6.9cm}|}
  \hline
  \textbf{Offset} & \textbf{Type} & \textbf{Description}
  \\\hline
  \$00 & asciiz & The long file name
  \\
  \$40 & byte & The lenngth of long file name
  \\
  \$41 & ascii & The "8.3" file name. The name part is padded with spaces to make
               it exactly 8 bytes. The 3 bytes of the extension follow. There is
               no . between the name and the extension. There is no NULL byte.
  \\
  \$4E & dword & The cluster number where the file begins. For sub-directories,
               this is where the FAT dir entries start for that sub-directory.
  \\
  \$52 & dword & The length of file in bytes.
  \\
  \$56 & dword & The type and attribute bits.
  \\\hline
  \end{tabular}
  }

  This is what the bits in the last byte mean. Bits 6 and 7 are undefined.
  {\setlength{\tabcolsep}{2mm}
  \begin{tabular}{|c|l|}
  \hline
  \textbf{Bit} & \textbf{Meaning if bit is set} \\
  \hline
  0 & Read only         \\
  1 & Hidden            \\
  2 & System            \\
  3 & Volume label      \\
  4 & Sub-directory     \\
  5 & Archive           \\
  \hline
  \end{tabular}
  }
\item [Postconditions:]
  Using hdos\_readdir again reads the next FAT dir entry in the directory.
\item [Errors:]
  \errordesc{7}{read timeout}{Reading the initial directory information took too
  long}
  \errordesc{8}{partition error}{An unspecified error occurred while handling
  the currently selected partition}
  \errordesc{10}{invalid address}{The address in Y is invalid. It must be
  $\leq$ \$7E}
  \errordesc{20}{read error}{An unspecified error occurred while reading}
  \errordesc{85}{invalid cluster}{An attempt was made to read past the end of
  the directory}
\item [Remarks:]
  If the long file name in the FAT dir entry is too long to copy into the
  destinary area, the Hypervisor skips the entry entrirely.

  The file names in FAT are encoded as UTF-16. The Hypervisor only reads the LSB
  of each 16-bit character. The Hypervisor does not convert file names into
  PETSCII.

  See hdos\_setup\_transfer\_area for more details about the value for the Y
  register.
\item [History:]
  \availablefrom{1.2}
\item [Example:]
  Checks if the file DIR1 is a sub-directory. Returns with the C flag set if it
  is.

  \TODO
\end{hyppotrap}


% ******************************************************************************
% readfile
% ******************************************************************************
\newpage
\begin{hyppotrap}{readfile}{D640}{1A}
\item [Service:]
  Reads the next sector of the current file into the sector buffer.
\item [Preconditions:]
  There is a current file open. Files can be opened with hdos\_openfile.
\item [Outputs:]
  \register{X}{The LSB of the number of bytes read}
  \register{Y}{The MSB of the number of bytes read}
\item [Postconditions:]
  The next call to hdos\_readfile will read the next sector of the current file
  or signal the end of the file.
\item [Errors:]
  \TODO
\item [Remarks:]
  To access the data, you need to either:
  \begin{itemize}
    \item map the sector buffer into the 16-bit address space;
    \item use an enhanced DMA transfer to copy the sector buffer (where? \TODO)
          into a buffer already mapping into the 16-bit address space; or
    \item use 32-bit load instructions to access the sector buffer directly.
  \end{itemize}

  If a full sector was read, Y:X will be \$0200. For the last sector of the
  file, Y:X may be less than that. Any bytes in sector buffer after Y:X are
  invalid and will not necessarily be zero.

  If you read past the end of the last sector, Y:X will be \$0000, A will be
  \$FF and the C flag will be set.

  While multiple files can be opened simultaneously, only the current file can
  be read. The current file is often the last file opened, but not always.
\item [Example:]
  Maps the sector buffer at \$DE00 and then reads each sector of the file calling
  proccesssector for each sector read. proccesssector is assumed to be defined
  elsewhere.
\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Unmap the colour RAM at $DC00
    ;; because that will prevent us from mapping in the sector buffer
    LDA #1
    TRB $D030
\end{verbatim}
\end{tcolorbox}

\ldots{} continues on the next page \ldots

\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Map the sector buffer at $DE00
    LDA #$81
    STA $D680
@nextsector:
    ;; Read the next sector
    LDA #$1A
    STA $D640
    CLV
    BCC @eoforerror
    ;; Call processsector (assumed to be defined elsewhere)
    JSR processsector
    BRA @nextsector
@eoforerror:
    ;; If the error code in A is $FF we have reached the end of the file
    ;; otherwise there's been an error
    CMP #$FF
    BNE @error
    RTS
@error:
    BRK
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% rename
% ******************************************************************************
\newpage
\begin{hyppotrap}{rename}{D640}{2A}
\item [Service:]
  Renames a file or sub-directory.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% rmdir
% ******************************************************************************
\begin{hyppotrap}{rmdir}{D640}{10}
\item [Service:]
  Removes a sub-directory.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% rmfile
% ******************************************************************************
\begin{hyppotrap}{rmfile}{D640}{26}
\item [Service:]
  Removes a files.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% seekfile
% ******************************************************************************
\begin{hyppotrap}{seekfile}{D640}{24}
\item [Service:]
  Seeks to a given sector in a file.
\notimplemented
\end{hyppotrap}


% ******************************************************************************
% selectdrive
% ******************************************************************************
\newpage
\begin{hyppotrap}{selectdrive}{D640}{06}
\item [Service:]
  Selects the currently selected drive (SD card partition).
\item [Preconditions:]
  The Hypervisor has assigned a drive number to the SD card partition.
\item [Inputs:]
  \register{X}{The drive number to become the new current drive}
\item [Postconditions:]
  getcurrentdrive returns the value that was in the X register.

  The Hypervisor services operate on the newly selected drive.
\item [Errors:]
  \errordesc{80}{no such drive}{The drive in the X register does not exist.
  The Hypervisor only assigns drive numbers to the SD card partitions it can
  read.}
\item [History:]
  \availablefrom{1.2}
\item [Example:]
  Tests if drive 2 exists by trying to select it. Returns with the C flag set if
  drive 2 exists.

\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
    ;; Preserve the current drive in Z so we can restore it later
    LDA #$04
    STA $D640
    CLV
    BCC @error
    TAZ
    ;; Try to select drive 2
    LDX #2
    LDA #$06
    STA $D640
    CLV
    BCC @mightnotexist
    ;; Transfer the previously selected drive number in Z to X
    TZA
    TAX
    ;; Restore the previously selected drive
    LDA #$06
    STA $D640
    CLV
    BCC @error
    ;; The C flag was already set by the Hypervisor service
    RTS
\end{verbatim}
\end{tcolorbox}

\ldots{} continues on the next page \ldots

\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
@mightnotexist:
    ;; If the error code in A is $80, the drive doesn't exist;
    ;; otherwise some other kind of error occured
    CMP #$80
    BNE @error
    ;; Clear the C flag because the drive doesn't exist
    CLC
    RTS
@error:
    BRK
\end{verbatim}
\end{tcolorbox}
\end{hyppotrap}


% ******************************************************************************
% setname
%
% Jimbo - Generally is this 8.3 or an LFN?
% ******************************************************************************
\newpage
\begin{hyppotrap}{setname}{D640}{2E}
\item [Service:]
  Sets the current Hypervisor filename.
\item [Preconditions:]
  The filename is stored in ASCII and ends with \$00 byte.

  The filename starts on a page boundary between \$0000 and \$7E00.
\item [Inputs:]
  \register{Y}{The MSB of the filename address.}
\item [Postconditions:]
  The Hypervisor has copied the filename into it's own data area.

  The hdos\_find* and hdos\_load* services use this filename.
\item [Side effects:]
  Sets the transfer area to \$YY00.
\item [Errors:]
  \errordesc{10}{invalid address}{The Y register is $>$ \$7E.}
  \errordesc{81}{name too long}{The filename is longer than 63 characters.}
\item [History:]
  \availablefrom{1.2}
\item [Remarks:]
  The filename must be between \$0000 and \$7E00. It must also begin on a
  page boundary. That is, its address must end with \$00. The current memory
  mapping is used. However, it is good practice to place it in the bottom 32KB
  of bank 0.

  The filenames in FAT are encoded in UTF-16. The Hypervisor only reads the LSB
  of each 16-bit character. The Hypervisor does not convert between ASCII and
  PETSCII.

  The Hypervisor accesses the files in the FAT file system on the internal and
  external SD cards. It does not access files on disks in floppy drives or in
  disk images.
\item [Example:]
  See the example in (where? \TODO).
\end{hyppotrap}


% ******************************************************************************
% writefile
% ******************************************************************************
\newpage
\begin{hyppotrap}{writefile}{D640}{1C}
\item [Service:]
  Writes the sector buffer to the current file.
\notimplemented
\end{hyppotrap}



%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------



\chapter{MEGA65 Hypervisor Services (old)}

The MEGA65's Hypervisor provides a number of services via Hypervisor Traps.
This chapter will describe these services.  For detailed information on how
Hypervisor Traps are facilitated by the CPU is described in \bookvref{cha:cpu}.

The hypervisor calls are identified by the trap register (\$D640 -- \$D67F), and
the value of the accumulator register when writing to the trap register.  Thus
a hypervisor call \$00:\$02 would be made via the following sequence of instructions:

\begin{screenoutput}
  LDA #$02         
  STA $D640+$00
  NOP                ; All traps calls MUST be followed by a NOP instruction
\end{screenoutput}

The values of the other registers or other structures will be described for
each individual call.

\section{General Services}

\subsection{\$00:\$00 -- Get Hypervisor Version}

Returns the version of the Hypervisor operating system and DOS components in the
four registers:

\begin{itemize}
  \item A = Hypervisor Operating System Major Version number. 
  \item X = Hypervisor Operating System Minor Version number. 
  \item Y = Hypervisor DOS Minor Version number. 
  \item Z = Hypervisor DOS Major Version number. 
\end{itemize}

These values can be used to check whether a given MEGA65 system's hypervisor
supports features that become available (or are deprecated) at particular versions.

\subsection{\$00:\$38 -- Get Current Error Code (geterrorcode)}

Returns the current error code from the Hypervisor.  The currently supported
error codes are:

\begin{itemize}
\item \$01 (1) -- Partition Not Interesting, indicating that an attempt to mount a partition was rejected because the partition was not of a supported type.
\item \$02 (2) -- Bad Signature, indicating that the signature bytes at the end of a partition table or of the first sector of a partition were missing or incorrect.
\item \$03 (3) -- An attempt was made to mount a FAT12 or FAT16 partition.  Only FAT32 partitions are supported.
\item \$04 (4) -- An attempt was made to mount a partition that has too many reserved sectors. The number of reserved sectors must be less than 65,536.
  \item \$05 (5) -- An attempt was made to mount a partition that does not have exactly two copies of the FAT structure.
\item \$06 (6) -- An attempt was made to mount a partition that contains a partition with too few clusters.
\item \$07 (7) -- A read timeout occurred.
  \item \$08 (8) -- An unspecified error occurred while handling a partition.
\item \$10 (16) -- An invalid address was supplied to the Setup Transfer Area For Other Calls function.
\item \$11 (17) -- An illegal value was supplied to a Hypervisor call.
\item \$20 (32) -- A read error occurred.
\item \$21 (33) -- A write error occurred.
\item \$80 (128) -- An attempt was made to select or operate on a disk or partition that does not exist.
\item \$81 (129) -- The supplied filename was too long.
\item \$82 (130) -- A Hypervisor call was made to a function that is not implemented. 
\item \$83 (131) -- An attempt was made to load a file into memory that is longer than 16MB.
\item \$84 (132) -- Too many files are open, and no free file descriptor could be obtained for the requested operation.
\item \$85 (133) -- The supplied cluster number is invalid.
\item \$86 (134) -- An attempt was made to operate on a directory, where a normal file was expected.
\item \$87 (135) -- An attempt was made to operate on a normal file, where a directory was expected.
\item \$88 (136) -- The requested file could not be located.
\item \$89 (137) -- An invalid file descriptor was supplied.
\item \$8A (138) -- A disk image file had the wrong length, and was rejected for this reason.
\item \$8B (139) -- A disk image was attempted to be mounted, but could not because it is fragmented on the file system.  Disk images must be stored contiguously on disk. This is because of the way that the SD card controller and floppy controller work: They load the starting sector of the disk image into special registers, and have no way to correctly handle a disk image that is stored in separate pieces on the disk. 
\item \$8C (140) -- The disk has no free space for the requested operation.
\item \$8D (141) -- An attempt was made to create a file that already exists, or to rename a file to have the name of a file that already exists.
\item \$8E (142) -- An attempt was made to create a file in a directory that cannot accommodate any more entries.
\item \$FF (255) -- The end of a file or directory was encountered.
\end{itemize}

\subsection{\$00:\$3A -- Setup Transfer Area for Other Calls (setup\_transfer\_area)}

Setup the transfer area for various hypervisor calls. The page number of the transfer area is supplied in the Y register.
This page must be between \$00 (0) and \$7E (126), thus indicating a transfer area starting between \$0000 and \$7E00 (0 and 32,256).
The transfer area is
256 bytes long for most calls.  Note that the transfer area is indicated using the processor's current memory mapping at
the time that a function is called.  However, it is good practice to always place it in the bottom 32KB of main memory.

\begin{itemize}
  \item Y = Page number of the transfer area (\$00 -- \$7E).
\end{itemize}

This call can produce the following error codes:

\begin{itemize}
\item \$10 (16) -- An invalid transfer area address was supplied, i.e., Y > \$7E (126).
\end{itemize}

\section{Disk/Storage Hypervisor Calls}

\subsection{\$00:\$02 -- Get Default Drive (SD card Partition)}

This call returns the default drive (SD card partition) number in the A register.

\subsection{\$00:\$04 -- Get Current Drive (SD card Partition)}

This call returns the current selected drive (SD card partition) in the A register.

\subsection{\$00:\$06 -- Select Drive (SD card Partition)}

This call sets the currently selected drive (SD card partition) to the drive indicated in the X register.

\begin{itemize}
  \item X = Selected drive (SD card partition) number.
\end{itemize}

This call can produce the following error codes:

\begin{itemize}
\item \$80 (128) -- An attempt was made to select or operate on a disk or partition that does not exist.
\end{itemize}

\subsection{\$00:\$08 -- {\em NOT IMPLEMENTED} Get Disk Size}

When implemented, this call will return information on the size of the currently selected disk (SD card partition).

\subsection{\$00:\$0A -- {\em NOT IMPLEMENTED} Get Current Working Directory}

When implemented, this call will return information on the currently selected directory or sub-directory.

\subsection{\$00:\$0C -- Change Working Directory}

Changes the current working directory to the directory specified in the dirent structure. The dirent structure
can be populated by using any of the findfirst, findnext, findfile, or readdir Hypervisor calls.

This call can produce the following error codes:

\begin{itemize}
\item \$87 (135) -- An attempt was made to operate on a normal file, where a directory was expected.
\end{itemize}

\subsection{\$00:\$0E -- {\em NOT IMPLEMENTED} Create Directory}

When implemented, this call will allow the creation of new subdirectories.

\subsection{\$00:\$10 -- {\em NOT IMPLEMENTED} Remove Directory}

When implemented, ths call will allow the removal of a directory.

\subsection{\$00:\$12 -- Open Directory (opendir)}

Open the current working directory.

On success, it returns the file descriptor of the opened directory in the A register.

This call can result in the following error codes:

\begin{itemize}
\item \$07 (7) -- A read timeout occurred.
  \item \$08 (8) -- An unspecified error occurred while handling a partition.
\item \$10 (16) -- An invalid address was supplied to the Setup Transfer Area For Other Calls function.
\item \$11 (17) -- An illegal value was supplied to a Hypervisor call.
\item \$20 (32) -- A read error occurred.
\item \$21 (33) -- A write error occurred.
\item \$80 (128) -- An attempt was made to select or operate on a disk or partition that does not exist.
\item \$84 (132) -- Too many files are open, and no free file descriptor could be obtained for the requested operation.
\end{itemize}

\subsection{\$00:\$14 -- Read Next Directory Entry (readdir)}
\subsection{\$00:\$16 -- Close Directory (closedir)}
\subsection{\$00:\$18 -- Open File (openfile)}
\subsection{\$00:\$1A -- Read From a File (readfile)}
\subsection{\$00:\$1C -- {\em NOT IMPLEMENTED} Write to a File (writefile)}
\subsection{\$00:\$1E -- {\em NOT IMPLEMENTED} Create File (mkfile)}

\subsection{\$00:\$20 -- Close a File (closefile)}
\subsection{\$00:\$22 -- Close All Open Files (closeall)}
\subsection{\$00:\$24 -- {\em NOT IMPLEMENTED} Seek to a Given Offset in a File (seekfile)}
\subsection{\$00:\$26 -- {\em NOT IMPLEMENTED} Delete a File (rmfile)}
\subsection{\$00:\$28 -- {\em NOT IMPLEMENTED} Get Information About a File (fstat)}
\subsection{\$00:\$2A -- {\em NOT IMPLEMENTED} Rename a File (rename)}
\subsection{\$00:\$2C -- {\em NOT IMPLEMENTED} Set time stamp of a file (filedate)}
\subsection{\$00:\$2E -- Set the current filename (setname)}

Sets the current Hypervisor filename to the ASCIIZ string stored at \$YYXX. The provided address
must be in the first 31KB of main memory.  Addresses at \$7F00 or above will result in errors.

The filename indicates a file in the current working directory of the SD card's FAT file system.
This call will {\em not} work with names of files that are stored on floppy disks or floppy disk
images.  

\subsection{\$00:\$30 -- Find first matching file (findfirst)}
\subsection{\$00:\$32 -- Find subsequent matching file (findnext)}
\subsection{\$00:\$34 -- Find matching file (one only) (findfile)}
\subsection{\$00:\$36 -- Load a File into Main Memory (loadfile)}

On success, this call loads the file specified by the setname Hypervisor call into the specified
address in main (chip) memory.  It is limited to files of 16MB size, and the first 16MB of
the address space.  The load address will be \$00ZZYYXX.

Addresses during loading will wrap around within the same 16MB region of memory, i.e., the most
significant address byte will not be incremented during loading.

\subsection{\$00:\$3C -- Change Working Directory to Root Directory of Selected Partition}
\subsection{\$00:\$3E -- Load a File into Attic Memory (loadfile\_attic)}

On success, this call loads the file specified by the setname Hypervisor call into the specified
address in the Attic RAM memory.  It is limited to files of 16MB size, and the first 16MB of
the attic RAM address space.  The load address will be \$08ZZYYXX.

Addresses during loading will wrap around within the same 16MB region of memory, i.e., the most
significant address byte will not be incremented during loading.

\section{Disk Image Management}

\subsection{\$00:\$40 -- Attach a D81 Disk Image to Drive 0}
\subsection{\$00:\$42 -- Detach All D81 Disk Images}
\subsection{\$00:\$44 -- Write Enable All Currently Attached D81 Disk Images}
\subsection{\$00:\$46 -- Attach a D81 Disk Image to Drive 1}

\section{Task and Process Management}

\subsection{\$00:\$50 -- {\em NOT IMPLEMENTED} Get Task List}
\subsection{\$00:\$52 -- {\em NOT IMPLEMENTED} Send Message to Another Task}
\subsection{\$00:\$54 -- {\em NOT IMPLEMENTED} Receive Messages From Other Tasks}
\subsection{\$00:\$56 -- {\em NOT IMPLEMENTED} Write Into Memory of Another Task}
\subsection{\$00:\$58 -- {\em NOT IMPLEMENTED} Read From Memory of Another Task}

\subsection{\$00:\$60 -- {\em NOT IMPLEMENTED} Terminate Another Task}
\subsection{\$00:\$62 -- {\em NOT IMPLEMENTED} Create a Native MEGA65 Task}
\subsection{\$00:\$64 -- {\em NOT IMPLEMENTED} Load File Into Task}
\subsection{\$00:\$66 -- {\em NOT IMPLEMENTED} Create a C64-Mode Task}
\subsection{\$00:\$68 -- {\em NOT IMPLEMENTED} Create a C65-Mode Task}
\subsection{\$00:\$6A -- {\em NOT IMPLEMENTED} Exit and Switch to Another Task}
\subsection{\$00:\$6C -- {\em NOT IMPLEMENTED} Context-Switch to Another Task}
\subsection{\$00:\$6E -- {\em NOT IMPLEMENTED} Exit This Task}

\subsection{\$00:\$70 -- Toggle Write Protection of ROM Area}
\subsection{\$00:\$72 -- Toggle 4510 vs 6502 Processor Mode}
\subsection{\$00:\$74 -- Get current 4510 memory MAPping}

Y = page where memory mapping is to be stored.  Six bytes will be returned:
Y must be <= \$7E.

\begin{itemize}
  \item \$00 - Low byte of MAPLO (lower 32KB RAM mapping)
  \item \$01 - High byte of MAPLO (lower 32KB RAM mapping)
  \item \$02 - Low byte of MAPHI (upper 32KB RAM mapping)
  \item \$03 - High byte of MAPHI (upper 32KB RAM mapping)
  \item \$04 - Megabyte offset for MAPLO (lower 32KB RAM mapping)
  \item \$05 - Megabyte offset for MAPHI (upper 32KB RAM mapping)
\end{itemize}

\subsection{\$00:\$76 -- Set 4510 memory MAPping}

This call performs the opposite of the Get 4510 memory MAPping, reading 6 bytes
from the memory page indicated by Y, and storing them into the current processor's mapping status.
Y must be <= \$7E.

\subsection{\$00:\$7C -- Write Character to Serial Monitor/Matrix Mode Interface}
\subsection{\$00:\$7E -- Reset MEGA65}

\subsection{\$01:\$00 -- Enable Write Protection of ROM Area}
\subsection{\$01:\$02 -- Disable Write Protection of ROM Area}

\section{System Partition \& Freezing}

\subsection{\$02:\$00 -- Read System Config Sector Into Memory}
\subsection{\$02:\$02 -- Write System Config Sector From Memory}
\subsection{\$02:\$04 -- Apply System Config Sector Current Loaded Into Memory}
\subsection{\$02:\$06 -- Set DMAgic Revision Based On Loaded ROM}

\subsection{\$02:\$10 -- Locate First Sector of Freeze Slot}
\subsection{\$02:\$12 -- Unfreeze From Freeze Slot}
\subsection{\$02:\$14 -- Read Freeze Region List}
\subsection{\$02:\$16 -- Get Number of Freeze Slots}

\subsection{\$03:\$XX -- Write Character to Serial Monitor/Matrix Mode Interface}

\section{Secure Mode}

\subsection{\$11:\$XX -- Request Enter Secure Mode}
\subsection{\$12:\$XX -- Request Exit Secure Mode}
\subsection{\$32:\$XX -- {\em DEPRECATED} Set Protected Hardware Configuration}

This call will be removed once the secure mode framework is more completely implemented.

Until it is removed, this call allows a process to request the setting of the protected hardware configuration to allow or restrict access to various sub-systems, including the SD card storage system.

\subsection{\$3F:\$XX -- Freeze Self}

