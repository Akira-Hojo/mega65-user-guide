\chapter{45IO27 Multi-Function IO Controller}

\section{Overview}

The 45IO27 is a multi-purpose IO controller that incorporates the functions of the
C65's F011 floppy controller, together with the MEGA65's SD card controller interface,
and a number of other miscellation IO functions.

Each of these major functions is covered in a separate section of this chapter

\section{F011-compatible Floppy Controller}

The MEGA65 computer is one of very few modern computers that still
includes first-class support for magnetic floppy drives.  It includes
a floppy controller that is backwards compatible with the C65's F011D
floppy drive controller.

However, unlike the F011D, the MEGA65's
floppy disk controller supports HD and ED media, and similar to the
1541 floppy drive, it also supports variable data rates, so that a
determined user could develop disk formats that store more data,
includ robust copy protection schemes, or both.

GCR encoding is not currently supported, but may be supported by a
future revision of the controller.  It may also be possible with some
creativity and effort to use the debug register interface to read
double-density GCR formatted media.  This is because there are debug
registers that can be queried to indicate the gap between each
successive magnetic domain -- which is sufficient to decode any disk
format. 

\subsection{Multiple Drive Support}

Like the C65's F011 floppy drive controller, the 45IO27 supports up to 8 drives.
The first two of those drives, drive 0 and drive 1, are assumed to be connected to a
standard 34-pin floppy cable, the same as used in standard PCs, i.e.,
with a twist in the cable to allow the use of two unjumpered drives.

As is described in later sections, it is possible to switch drive 0
and drive 1's position, without having to change cabling. Similarly,
either or both of the first two drives may reference a real floppy
drive, a D81 disk image stored on an attached SD card, or redirected
to the floppy drive virtualisation service, so that the sector
accesses can be handled by a connected computer, e.g., as part of a
comfortable and efficient cross-development environment.

The remaining six drives are supported only in conjunction with a
future C1565-compatible external drive port.

\subsection{Reading From Disks}

The 45IO27 support two main modes of reading sectors from a
disk: byte-by-byte, and via a memory-mapped sector buffer.

The byte-by-byte mechanism consists of having a loop wait for the DRQ
signal to be asserted, and then reading the byte of data from the DATA
register (\$D087).

The memory-mapped sector buffer method consists of waiting for the
BUSY flag to clear, indicating that the entire sector has been read,
and then directly accessing the sector buffer located at \$FFD6C00 --
\$FFD6DFF. Care should be taken to ensure that bit 7 of \$D689 is
cleared, so that the floppy sector buffer is visible, rather than the
SD card sector buffer.

The memory-mapped sector buffer has the advantage that it can be
accessed via DMA, allowing for very efficient copies.  Also, it allows
for loading a sector to occur in the background, while your programme
gets on with more interesting things in the meantime.

But before you have any data to read, you must first tell the floppy
controller to read a sector.  To do this, first set the SIDE1 flag in
bit 3 of \$D080 if you wish to read a sector from the reverse side of the disk,
or clear it if you wish to read a sector from the first side of the
disk.
Next, load the track, sector and
side number into the TRACK, SECTOR and SIDE registers (\$D084, \$D085
and \$D086, respectively). Then write an appropriate read command
value into \$D080.  This will normally be \$40 (64).  You then wait
for the RDREQ signal (\$D083, bit 7) to go high, to indicate that the
sector has been found. You then either wait for each occassion when
DRQ goes high, and read byte-by-byte in such a loop, or wait for the
BUSY flag to clear and the DRQ and EQ flags to go high, and then
access the sector buffer directly.  

What has not been discussed above is stepping the head to the correct
track.  By default, the 45IO27 uses its ``auto-tune'' function (\$D689,
bit 4) to compare the track number of sectors passing under the head
of the disk drive with the requested track.  If the track matches,
then it knows that it is on the correct track.  If not, it will
periodically seek the head in the direction of the correct track.

This considerably simplifies operation, by relieving the programmer
from having to step the head, and recover from mis-steps, where the
expected and actual tracks diverge. It is therefore recommended that
programmers leave the auto-tune function enabled at all times --
unless you purposely intend to create disks with incorrectly numbered
tracks.

With determination and perserverence, it should be possible
to create disks that use the auto-tune function to play simple tunes.
This is not recommended.

\subsection{Disk Layout and 1581 Logical Sectors}

The 1581 disk format is unusual in that the physical sectors on the
disk are a different size of the size of the data blocks that it
presents to the user.  Specifically, the disks use 512 byte sectors,
while the 1581 (and C65) DOS present 256 byte data blocks.
Two blocks are stored in each physical sector.  Also, the physical
track numbers are from 0 to 79, while the logical track numbers of the
DOS are 1 to 80.  Physical sectors are also numbered from 1 to 10,
while logical block numbers begin are 0 to 39.

This means that if you want to find a 1581 logical sector, you need to
know which physical sector it will be found in.  To determine the
physical sector that contains a block, you first subtract one from the
track number, and then divide the sector number by two.  Logical
sectors 0 to 19 of each track are located in physical sectors 1 to 10
on the first side of the disk.  Logical sectors 20 to 39 are 
located in physical sectors 1 to 10 on the reverse side of the disk.  

Thus we can map a some logical track and sector $t$,$s$ to the
physical track, side and sector as follows:

$track = t - 1$

$sector = (s/2)+1, IFF s < 20, ELSE = ((s-20)/2) + 1$

$side = 0 IFF sector < 20$

It is also worth noting that the 45IO27 is capable of reading from
tracks beyond track 80, provided that the disk drive is capable of
this.  Almost all 3.5 inch floppy drives are capable of reading at
least one extra track, as historically manufacturers of floppy disks
stored information about the disk on the 81st track.  In our
experience almost all drives will also be able to access an 82nd
track.


\subsection{Writing To Disks}

The current revision of the 45IO27 does not support writing to disks.
This will be corrected in a future revision.  However, the determined
user may still be able to write to disks by manipulating the WGATE and
WDATA signals of the \$D6A0 register.  However, this is not
recommended.

\subsection{Using HD, ED Drives and/or variable Data Rates}

The mechanism for using high-density (HD) and extended-density (ED)
media and variable data rates are all identical on the 45IO27:  You
simply set the interval rate (DATARATE) in the \$D6A2 register.

The register is used as a divisor of the system bus frequency
(40.5MHz).  Thus for 1581-compatible double-density (DD) media which
uses a data rate of 500KHz, this register should contain 40.5MHz / 500KHz = 81.

High-density media uses a 1MHz data rate, and thus should contain 40,
and extended-density media with its 2MHz data rate should have this
field set to 20.  Depending on the HD or ED drive used, it may be
necessary to clear or assert the DENSITY signal (\$D6A0 bit 7), or
take other specific ations.  However, in our experience, most HD
drives do not require any manual manipulation of this signal: Instead
simply set the DATARATE register to the correct value, and begin
accessing the disk.

Note that the DATARATE register takes effect instantaneously.  This
means that it is possible to change the data rate for different
tracks, sectors, or even bytes within sectors.

This means that it
would be possible to, for example, use standard 500KHz DD encoding for
the directory track and one data track, and then switch to HD encoding for the other 79
tracks of a disk. The result would be a disk that could contain a
boot-loader programme and directory that can be read in a 1581, and
that could be used to switch to the faster and higher-density HD
encoding for the remaining data tracks.  This could even be done for
half of a disk, so that when used in a 1581, it loads at the DD speed,
but when inserted in a MEGA65, it uses the HD data tracks, allowing
the programme to load twice as fast, and fit twice as much data.

You are really only limited by your imagination, available time, and
the limited number of people who are still interested in inserting a
floppy disk into their computer!

\subsection{F011 Floppy Controller Registers}

The following are the set of F011 compatibility registers of the 45IO47.
Note that registers related to the use of SD-card based storage are found in the corresponding section below.

\input{regtable_FDC.C65}

\section{SD Card Controller and F011 Virtualisation Functions}

For those situations where you do not wish to use real floppy disks,
the 45IO27 supports two complementary alternative modes:

\begin{itemize}
\item SD-Card Based Disk Image Access.
\item Virtualised Disk Image Access.
\end{itemize}

\subsection{SD-Card Based Disk Image Access}

XXX - D81 and ``MEGA Disk'' images (800KiB and 64MiB)

\subsection{F011 Virtualisation}

In addition to allowing automatic read and write access to SD-card
based D81 images, it is possible to connect a programme to the serial
monitor interface that provides and accepts data as though it were the
floppy disk.

This is commonly used in a cross-development
environment, where you wish to frequently modify a disk image that is
used by a programme you are developing -- without the need to
continually push new versions of the disk image on the MEGA65's
SD-Card first. It also has the added benefit that it allows you to
easily visualise which sectors are being read from and written to,
which can help speed up development and debugging of your programme.

This function operates together with the MEGA65's Hypervisor by
triggering hyperrupts (that is, interrupts that activate the
Hypervisor).  There is then special code in the Hypervisor that
communicates with the {\tt m65} programme via the serial monitor
interface.

If that all sounds rather complex, all you need to know is that to use
this function, you run the {\tt m65} utility with arguments like
{\tt -d image.d81}.  This should automatically establish the link with
the MEGA65.  If the BASIC interprettor stops responding, press the
reset button (not the power switch) on the left side of your MEGA65,
and it should return to the BASIC's {\tt READY.} prompt -- and if your
supplied disk image has a C65 auto-boot function, then it should
automatically start booting.

This function works very well if the host computer runs Linux, and
will allow loading at a speed of around 60KiB per second.  However, it
may be much slower on Windows or Apple OSX-based systems.

Of course to use this, you will also need an interface module and/or
cable to connect your cross-development system to the MEGA65's serial
monitor interface. This is most easily done using a Trenz TE0790-03
JTAG adapter and mini-USB cable.

More information on using this interface and the {\tt m65} tool can be
found in \bookvref{cha:transfer-and-debug-tools}.

\section{Touch Panel Interface}

\section{Audio Support Functions}

\section{Miscellaneous IO Functions}

